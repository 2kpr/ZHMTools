#include <cstdio>
#include <filesystem>
#include <unordered_map>
#include <unordered_set>
#include <fstream>

#include <External/pugixml.hpp>
#include <External/Hash.h>

#if _WIN32
#define EXECUTABLE "ModuleInfoParser.exe"
#define SAMPLE_PATH "C:\\path\\to\\"
#else
#define EXECUTABLE "./ModuleInfoParser"
#define SAMPLE_PATH "/path/to/"
#endif

void PrintHelp()
{
	printf("Usage: " EXECUTABLE " <moduleinfo-folder> <output-folder>\n");
}

static std::unordered_set<std::string> g_PropertyNames;
static std::unordered_map<std::string, std::unordered_map<std::string, std::string>> g_Enums;

void ParseModuleInfo(const std::filesystem::path& p_Path)
{
	printf("Parsing module '%s'.\n", p_Path.string().c_str());

	pugi::xml_document s_Doc;
	const pugi::xml_parse_result s_Result = s_Doc.load_file(p_Path.c_str());

	if (!s_Result)
	{
		fprintf(stderr, "Could not parse '%s'. Error: %s\n", p_Path.string().c_str(), s_Result.description());
		return;
	}

	const auto& s_ModuleInfo = s_Doc.child("moduleinfo");

	const auto& s_Classes = s_ModuleInfo.child("classes");

	for (const auto& s_Class : s_Classes.children("class"))
	{
		const auto& s_Properties = s_Class.child("properties");

		for (const auto& s_Property : s_Properties.children("property"))
		{
			const auto& s_PropertyName = s_Property.attribute("Name").value();
			g_PropertyNames.insert(s_PropertyName);
		}
	}

	const auto& s_Enums = s_ModuleInfo.child("enums");

	for (const auto& s_Enum : s_Enums.children("enum"))
	{
		const auto& s_EnumName = s_Enum.attribute("name").value();

		std::unordered_map<std::string, std::string> s_EnumItems;

		for (const auto& s_Item : s_Enum.child("items").children("item"))
		{
			const auto& s_ItemName = s_Item.attribute("name").value();
			const auto& s_ItemValue = s_Item.attribute("value").value();

			s_EnumItems[s_ItemName] = s_ItemValue;
		}

		g_Enums[s_EnumName] = s_EnumItems;
	}
}

int main(int argc, char** argv)
{
	if (argc != 3)
	{
		PrintHelp();
		return 1;
	}

	for (const auto& s_DirEntry : std::filesystem::directory_iterator(argv[1]))
	{
		if (!is_regular_file(s_DirEntry))
			continue;

		if (s_DirEntry.path().extension() != ".moduleinfo")
			continue;

		try
		{
			ParseModuleInfo(s_DirEntry.path());
		}
		catch (std::exception& p_Exception)
		{
			fprintf(stderr, "Could not parse '%s'. Error: %s\n", s_DirEntry.path().string().c_str(), p_Exception.what());
		}
	}

	// Add missing properties.
	g_PropertyNames.insert("m_uri");
	g_PropertyNames.insert("m_nHeightOffset");
	g_PropertyNames.insert("m_nOnNavGrid");
	g_PropertyNames.insert("m_aBytes");
	g_PropertyNames.insert("m_sComponentName");
	g_PropertyNames.insert("m_aArgs");
	g_PropertyNames.insert("m_sStr");
	g_PropertyNames.insert("m_EntityID");
	g_PropertyNames.insert("m_sExposedEntity");
	g_PropertyNames.insert("m_nTicks");
	g_PropertyNames.insert("m_IDHigh");
	g_PropertyNames.insert("m_IDLow");
	g_PropertyNames.insert("m_aSpeakerMatrix");
	g_PropertyNames.insert("m_nValue");

	std::ofstream s_OutputHeader;
	std::ofstream s_OutputSource;

	const std::filesystem::path s_OutputPath(argv[2]);

	s_OutputHeader.open(s_OutputPath / "HMAData.h", std::ofstream::out);
	s_OutputSource.open(s_OutputPath / "HMAData.cpp", std::ofstream::out);

	s_OutputHeader << "/*" << std::endl;
	s_OutputHeader << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	s_OutputHeader << " *" << std::endl;
	s_OutputHeader << " * If you wish to regenerate this file because of a game update use the ZHMTools ModuleInfoParser tool:" << std::endl;
	s_OutputHeader << " * https://github.com/OrfeasZ/ZHMTools/releases" << std::endl;
	s_OutputHeader << " */" << std::endl;
	s_OutputHeader << std::endl;
	s_OutputHeader << "#pragma once" << std::endl;
	s_OutputHeader << std::endl;
	s_OutputHeader << "#include <cstdint>" << std::endl;
	s_OutputHeader << "#include <unordered_map>" << std::endl;
	s_OutputHeader << std::endl;
	s_OutputHeader << "class HMAData" << std::endl;
	s_OutputHeader << "{" << std::endl;
	s_OutputHeader << "public:" << std::endl;
	s_OutputHeader << "\tstatic std::unordered_map<uint32_t, std::string> PropertyNames;" << std::endl;
	s_OutputHeader << "\tstatic std::unordered_map<std::string, std::unordered_map<std::string, int32_t>> Enums;" << std::endl;
	s_OutputHeader << "};" << std::endl;

	s_OutputSource << "/*" << std::endl;
	s_OutputSource << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	s_OutputSource << " *" << std::endl;
	s_OutputSource << " * If you wish to regenerate this file because of a game update use the ZHMTools ModuleInfoParser tool:" << std::endl;
	s_OutputSource << " * https://github.com/OrfeasZ/ZHMTools/releases" << std::endl;
	s_OutputSource << " */" << std::endl;
	s_OutputSource << std::endl;
	s_OutputSource << "#include \"HMAData.h\"" << std::endl;
	s_OutputSource << std::endl;

	s_OutputSource << "std::unordered_map<uint32_t, std::string> HMAData::PropertyNames = {";

	for (const auto& s_PropertyName : g_PropertyNames)
	{
		s_OutputSource << "{" << Hash::Crc32(s_PropertyName) << ", \"" << s_PropertyName << "\"},";
	}

	s_OutputSource << "};" << std::endl;

	s_OutputSource << "std::unordered_map<std::string, std::unordered_map<std::string, int32_t>> HMAData::Enums = {";

	for (const auto& [s_EnumName, s_EnumItems] : g_Enums)
	{
		s_OutputSource << "{";
		s_OutputSource << "\"" << s_EnumName << "\",{";

		for (const auto& [s_ItemName, s_ItemValue] : s_EnumItems)
		{
			s_OutputSource << "{\"" << s_ItemName << "\"," << s_ItemValue << "},";
		}

		s_OutputSource << "}},";
	}

	s_OutputSource << "};" << std::endl;

	return 0;
}
