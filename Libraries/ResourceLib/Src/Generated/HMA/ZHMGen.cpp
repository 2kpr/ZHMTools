/*
 * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing.
 *
 * If you wish to regenerate this file because of a game update use the ZHMTools CodeGen tool:
 * https://github.com/OrfeasZ/ZHMTools/releases
 */

#include "ZHMGen.h"
#include "ZHMProperties.h"
#include "ZHMEnums.h"
#include <External/simdjson_helpers.h>
#include <utility>

ZHMTypeInfo BoneId::TypeInfo = ZHMTypeInfo("BoneId", sizeof(BoneId), alignof(BoneId), BoneId::WriteJson, BoneId::WriteSimpleJson, BoneId::FromSimpleJson, BoneId::Serialize, BoneId::Equals);

void BoneId::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void BoneId::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void BoneId::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	BoneId s_Object {};

	*reinterpret_cast<BoneId*>(p_Target) = s_Object;
}

void BoneId::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

}

bool BoneId::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<BoneId*>(p_Left);
	auto* s_Right = reinterpret_cast<BoneId*>(p_Right);

	return *s_Left == *s_Right;
}

bool BoneId::operator==(const BoneId& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<BoneId>)
		return false;


	return true;
}

ZHMTypeInfo IActorAction::TypeInfo = ZHMTypeInfo("IActorAction", sizeof(IActorAction), alignof(IActorAction), IActorAction::WriteJson, IActorAction::WriteSimpleJson, IActorAction::FromSimpleJson, IActorAction::Serialize, IActorAction::Equals);

void IActorAction::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorAction*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IActorAction::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorAction*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActorAction::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IActorAction s_Object {};

	*reinterpret_cast<IActorAction*>(p_Target) = s_Object;
}

void IActorAction::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActorAction*>(p_Object);

}

bool IActorAction::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActorAction*>(p_Left);
	auto* s_Right = reinterpret_cast<IActorAction*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActorAction::operator==(const IActorAction& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActorAction>)
		return false;


	return true;
}

ZHMTypeInfo IAnimPlayerEntity::TypeInfo = ZHMTypeInfo("IAnimPlayerEntity", sizeof(IAnimPlayerEntity), alignof(IAnimPlayerEntity), IAnimPlayerEntity::WriteJson, IAnimPlayerEntity::WriteSimpleJson, IAnimPlayerEntity::FromSimpleJson, IAnimPlayerEntity::Serialize, IAnimPlayerEntity::Equals);

void IAnimPlayerEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IAnimPlayerEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IAnimPlayerEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IAnimPlayerEntity s_Object {};

	*reinterpret_cast<IAnimPlayerEntity*>(p_Target) = s_Object;
}

void IAnimPlayerEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

}

bool IAnimPlayerEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IAnimPlayerEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IAnimPlayerEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IAnimPlayerEntity::operator==(const IAnimPlayerEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IAnimPlayerEntity>)
		return false;


	return true;
}

ZHMTypeInfo IBoneAnimator::TypeInfo = ZHMTypeInfo("IBoneAnimator", sizeof(IBoneAnimator), alignof(IBoneAnimator), IBoneAnimator::WriteJson, IBoneAnimator::WriteSimpleJson, IBoneAnimator::FromSimpleJson, IBoneAnimator::Serialize, IBoneAnimator::Equals);

void IBoneAnimator::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IBoneAnimator::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBoneAnimator::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBoneAnimator s_Object {};

	*reinterpret_cast<IBoneAnimator*>(p_Target) = s_Object;
}

void IBoneAnimator::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

}

bool IBoneAnimator::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBoneAnimator*>(p_Left);
	auto* s_Right = reinterpret_cast<IBoneAnimator*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBoneAnimator::operator==(const IBoneAnimator& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBoneAnimator>)
		return false;


	return true;
}

ZHMTypeInfo IBoneCollidable::TypeInfo = ZHMTypeInfo("IBoneCollidable", sizeof(IBoneCollidable), alignof(IBoneCollidable), IBoneCollidable::WriteJson, IBoneCollidable::WriteSimpleJson, IBoneCollidable::FromSimpleJson, IBoneCollidable::Serialize, IBoneCollidable::Equals);

void IBoneCollidable::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IBoneCollidable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBoneCollidable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBoneCollidable s_Object {};

	*reinterpret_cast<IBoneCollidable*>(p_Target) = s_Object;
}

void IBoneCollidable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

}

bool IBoneCollidable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBoneCollidable*>(p_Left);
	auto* s_Right = reinterpret_cast<IBoneCollidable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBoneCollidable::operator==(const IBoneCollidable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBoneCollidable>)
		return false;


	return true;
}

ZHMTypeInfo IComponentInterface::TypeInfo = ZHMTypeInfo("IComponentInterface", sizeof(IComponentInterface), alignof(IComponentInterface), IComponentInterface::WriteJson, IComponentInterface::WriteSimpleJson, IComponentInterface::FromSimpleJson, IComponentInterface::Serialize, IComponentInterface::Equals);

void IComponentInterface::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IComponentInterface::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IComponentInterface::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IComponentInterface s_Object {};

	*reinterpret_cast<IComponentInterface*>(p_Target) = s_Object;
}

void IComponentInterface::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

}

bool IComponentInterface::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IComponentInterface*>(p_Left);
	auto* s_Right = reinterpret_cast<IComponentInterface*>(p_Right);

	return *s_Left == *s_Right;
}

bool IComponentInterface::operator==(const IComponentInterface& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IComponentInterface>)
		return false;


	return true;
}

ZHMTypeInfo IEventConsumerCollection::TypeInfo = ZHMTypeInfo("IEventConsumerCollection", sizeof(IEventConsumerCollection), alignof(IEventConsumerCollection), IEventConsumerCollection::WriteJson, IEventConsumerCollection::WriteSimpleJson, IEventConsumerCollection::FromSimpleJson, IEventConsumerCollection::Serialize, IEventConsumerCollection::Equals);

void IEventConsumerCollection::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IEventConsumerCollection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IEventConsumerCollection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IEventConsumerCollection s_Object {};

	*reinterpret_cast<IEventConsumerCollection*>(p_Target) = s_Object;
}

void IEventConsumerCollection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

}

bool IEventConsumerCollection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IEventConsumerCollection*>(p_Left);
	auto* s_Right = reinterpret_cast<IEventConsumerCollection*>(p_Right);

	return *s_Left == *s_Right;
}

bool IEventConsumerCollection::operator==(const IEventConsumerCollection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IEventConsumerCollection>)
		return false;


	return true;
}

ZHMTypeInfo IHM5Door::TypeInfo = ZHMTypeInfo("IHM5Door", sizeof(IHM5Door), alignof(IHM5Door), IHM5Door::WriteJson, IHM5Door::WriteSimpleJson, IHM5Door::FromSimpleJson, IHM5Door::Serialize, IHM5Door::Equals);

void IHM5Door::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5Door*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IHM5Door::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5Door*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHM5Door::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IHM5Door s_Object {};

	*reinterpret_cast<IHM5Door*>(p_Target) = s_Object;
}

void IHM5Door::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHM5Door*>(p_Object);

}

bool IHM5Door::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHM5Door*>(p_Left);
	auto* s_Right = reinterpret_cast<IHM5Door*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHM5Door::operator==(const IHM5Door& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHM5Door>)
		return false;


	return true;
}

ZHMTypeInfo IHM5WeaponInventory::TypeInfo = ZHMTypeInfo("IHM5WeaponInventory", sizeof(IHM5WeaponInventory), alignof(IHM5WeaponInventory), IHM5WeaponInventory::WriteJson, IHM5WeaponInventory::WriteSimpleJson, IHM5WeaponInventory::FromSimpleJson, IHM5WeaponInventory::Serialize, IHM5WeaponInventory::Equals);

void IHM5WeaponInventory::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IHM5WeaponInventory::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHM5WeaponInventory::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IHM5WeaponInventory s_Object {};

	*reinterpret_cast<IHM5WeaponInventory*>(p_Target) = s_Object;
}

void IHM5WeaponInventory::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

}

bool IHM5WeaponInventory::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHM5WeaponInventory*>(p_Left);
	auto* s_Right = reinterpret_cast<IHM5WeaponInventory*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHM5WeaponInventory::operator==(const IHM5WeaponInventory& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHM5WeaponInventory>)
		return false;


	return true;
}

ZHMTypeInfo IMorphemeCutSequenceAnimatable::TypeInfo = ZHMTypeInfo("IMorphemeCutSequenceAnimatable", sizeof(IMorphemeCutSequenceAnimatable), alignof(IMorphemeCutSequenceAnimatable), IMorphemeCutSequenceAnimatable::WriteJson, IMorphemeCutSequenceAnimatable::WriteSimpleJson, IMorphemeCutSequenceAnimatable::FromSimpleJson, IMorphemeCutSequenceAnimatable::Serialize, IMorphemeCutSequenceAnimatable::Equals);

void IMorphemeCutSequenceAnimatable::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IMorphemeCutSequenceAnimatable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeCutSequenceAnimatable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMorphemeCutSequenceAnimatable s_Object {};

	*reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Target) = s_Object;
}

void IMorphemeCutSequenceAnimatable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

}

bool IMorphemeCutSequenceAnimatable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeCutSequenceAnimatable::operator==(const IMorphemeCutSequenceAnimatable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeCutSequenceAnimatable>)
		return false;


	return true;
}

ZHMTypeInfo IMorphemeEventConsumer::TypeInfo = ZHMTypeInfo("IMorphemeEventConsumer", sizeof(IMorphemeEventConsumer), alignof(IMorphemeEventConsumer), IMorphemeEventConsumer::WriteJson, IMorphemeEventConsumer::WriteSimpleJson, IMorphemeEventConsumer::FromSimpleJson, IMorphemeEventConsumer::Serialize, IMorphemeEventConsumer::Equals);

void IMorphemeEventConsumer::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IMorphemeEventConsumer::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeEventConsumer::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMorphemeEventConsumer s_Object {};

	*reinterpret_cast<IMorphemeEventConsumer*>(p_Target) = s_Object;
}

void IMorphemeEventConsumer::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

}

bool IMorphemeEventConsumer::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeEventConsumer*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeEventConsumer*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeEventConsumer::operator==(const IMorphemeEventConsumer& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeEventConsumer>)
		return false;


	return true;
}

ZHMTypeInfo IRenderCompositorEntity::TypeInfo = ZHMTypeInfo("IRenderCompositorEntity", sizeof(IRenderCompositorEntity), alignof(IRenderCompositorEntity), IRenderCompositorEntity::WriteJson, IRenderCompositorEntity::WriteSimpleJson, IRenderCompositorEntity::FromSimpleJson, IRenderCompositorEntity::Serialize, IRenderCompositorEntity::Equals);

void IRenderCompositorEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IRenderCompositorEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IRenderCompositorEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IRenderCompositorEntity s_Object {};

	*reinterpret_cast<IRenderCompositorEntity*>(p_Target) = s_Object;
}

void IRenderCompositorEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

}

bool IRenderCompositorEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IRenderCompositorEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IRenderCompositorEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IRenderCompositorEntity::operator==(const IRenderCompositorEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IRenderCompositorEntity>)
		return false;


	return true;
}

ZHMTypeInfo IRenderMaterialDescriptor::TypeInfo = ZHMTypeInfo("IRenderMaterialDescriptor", sizeof(IRenderMaterialDescriptor), alignof(IRenderMaterialDescriptor), IRenderMaterialDescriptor::WriteJson, IRenderMaterialDescriptor::WriteSimpleJson, IRenderMaterialDescriptor::FromSimpleJson, IRenderMaterialDescriptor::Serialize, IRenderMaterialDescriptor::Equals);

void IRenderMaterialDescriptor::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IRenderMaterialDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IRenderMaterialDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IRenderMaterialDescriptor s_Object {};

	*reinterpret_cast<IRenderMaterialDescriptor*>(p_Target) = s_Object;
}

void IRenderMaterialDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Object);

}

bool IRenderMaterialDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IRenderMaterialDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<IRenderMaterialDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool IRenderMaterialDescriptor::operator==(const IRenderMaterialDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IRenderMaterialDescriptor>)
		return false;


	return true;
}

ZHMTypeInfo ISoundGroup::TypeInfo = ZHMTypeInfo("ISoundGroup", sizeof(ISoundGroup), alignof(ISoundGroup), ISoundGroup::WriteJson, ISoundGroup::WriteSimpleJson, ISoundGroup::FromSimpleJson, ISoundGroup::Serialize, ISoundGroup::Equals);

void ISoundGroup::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundGroup*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ISoundGroup::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundGroup*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISoundGroup::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISoundGroup s_Object {};

	*reinterpret_cast<ISoundGroup*>(p_Target) = s_Object;
}

void ISoundGroup::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISoundGroup*>(p_Object);

}

bool ISoundGroup::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISoundGroup*>(p_Left);
	auto* s_Right = reinterpret_cast<ISoundGroup*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISoundGroup::operator==(const ISoundGroup& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISoundGroup>)
		return false;


	return true;
}

ZHMTypeInfo ISoundListenerPositionReceiver::TypeInfo = ZHMTypeInfo("ISoundListenerPositionReceiver", sizeof(ISoundListenerPositionReceiver), alignof(ISoundListenerPositionReceiver), ISoundListenerPositionReceiver::WriteJson, ISoundListenerPositionReceiver::WriteSimpleJson, ISoundListenerPositionReceiver::FromSimpleJson, ISoundListenerPositionReceiver::Serialize, ISoundListenerPositionReceiver::Equals);

void ISoundListenerPositionReceiver::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundListenerPositionReceiver*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ISoundListenerPositionReceiver::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundListenerPositionReceiver*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISoundListenerPositionReceiver::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISoundListenerPositionReceiver s_Object {};

	*reinterpret_cast<ISoundListenerPositionReceiver*>(p_Target) = s_Object;
}

void ISoundListenerPositionReceiver::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISoundListenerPositionReceiver*>(p_Object);

}

bool ISoundListenerPositionReceiver::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISoundListenerPositionReceiver*>(p_Left);
	auto* s_Right = reinterpret_cast<ISoundListenerPositionReceiver*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISoundListenerPositionReceiver::operator==(const ISoundListenerPositionReceiver& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISoundListenerPositionReceiver>)
		return false;


	return true;
}

ZHMTypeInfo ISoundUpdateListener::TypeInfo = ZHMTypeInfo("ISoundUpdateListener", sizeof(ISoundUpdateListener), alignof(ISoundUpdateListener), ISoundUpdateListener::WriteJson, ISoundUpdateListener::WriteSimpleJson, ISoundUpdateListener::FromSimpleJson, ISoundUpdateListener::Serialize, ISoundUpdateListener::Equals);

void ISoundUpdateListener::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundUpdateListener*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ISoundUpdateListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundUpdateListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISoundUpdateListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISoundUpdateListener s_Object {};

	*reinterpret_cast<ISoundUpdateListener*>(p_Target) = s_Object;
}

void ISoundUpdateListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISoundUpdateListener*>(p_Object);

}

bool ISoundUpdateListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISoundUpdateListener*>(p_Left);
	auto* s_Right = reinterpret_cast<ISoundUpdateListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISoundUpdateListener::operator==(const ISoundUpdateListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISoundUpdateListener>)
		return false;


	return true;
}

ZHMTypeInfo ISoundVolumetricGeomSplinePoint::TypeInfo = ZHMTypeInfo("ISoundVolumetricGeomSplinePoint", sizeof(ISoundVolumetricGeomSplinePoint), alignof(ISoundVolumetricGeomSplinePoint), ISoundVolumetricGeomSplinePoint::WriteJson, ISoundVolumetricGeomSplinePoint::WriteSimpleJson, ISoundVolumetricGeomSplinePoint::FromSimpleJson, ISoundVolumetricGeomSplinePoint::Serialize, ISoundVolumetricGeomSplinePoint::Equals);

void ISoundVolumetricGeomSplinePoint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundVolumetricGeomSplinePoint*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ISoundVolumetricGeomSplinePoint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundVolumetricGeomSplinePoint*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISoundVolumetricGeomSplinePoint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISoundVolumetricGeomSplinePoint s_Object {};

	*reinterpret_cast<ISoundVolumetricGeomSplinePoint*>(p_Target) = s_Object;
}

void ISoundVolumetricGeomSplinePoint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISoundVolumetricGeomSplinePoint*>(p_Object);

}

bool ISoundVolumetricGeomSplinePoint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISoundVolumetricGeomSplinePoint*>(p_Left);
	auto* s_Right = reinterpret_cast<ISoundVolumetricGeomSplinePoint*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISoundVolumetricGeomSplinePoint::operator==(const ISoundVolumetricGeomSplinePoint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISoundVolumetricGeomSplinePoint>)
		return false;


	return true;
}

ZHMTypeInfo IStreamingStateManagerEntity::TypeInfo = ZHMTypeInfo("IStreamingStateManagerEntity", sizeof(IStreamingStateManagerEntity), alignof(IStreamingStateManagerEntity), IStreamingStateManagerEntity::WriteJson, IStreamingStateManagerEntity::WriteSimpleJson, IStreamingStateManagerEntity::FromSimpleJson, IStreamingStateManagerEntity::Serialize, IStreamingStateManagerEntity::Equals);

void IStreamingStateManagerEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IStreamingStateManagerEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IStreamingStateManagerEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IStreamingStateManagerEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IStreamingStateManagerEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IStreamingStateManagerEntity s_Object {};

	*reinterpret_cast<IStreamingStateManagerEntity*>(p_Target) = s_Object;
}

void IStreamingStateManagerEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IStreamingStateManagerEntity*>(p_Object);

}

bool IStreamingStateManagerEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IStreamingStateManagerEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IStreamingStateManagerEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IStreamingStateManagerEntity::operator==(const IStreamingStateManagerEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IStreamingStateManagerEntity>)
		return false;


	return true;
}

ZHMTypeInfo ITriggerListener::TypeInfo = ZHMTypeInfo("ITriggerListener", sizeof(ITriggerListener), alignof(ITriggerListener), ITriggerListener::WriteJson, ITriggerListener::WriteSimpleJson, ITriggerListener::FromSimpleJson, ITriggerListener::Serialize, ITriggerListener::Equals);

void ITriggerListener::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ITriggerListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ITriggerListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ITriggerListener s_Object {};

	*reinterpret_cast<ITriggerListener*>(p_Target) = s_Object;
}

void ITriggerListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

}

bool ITriggerListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ITriggerListener*>(p_Left);
	auto* s_Right = reinterpret_cast<ITriggerListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool ITriggerListener::operator==(const ITriggerListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ITriggerListener>)
		return false;


	return true;
}

ZHMTypeInfo ITriggerShape::TypeInfo = ZHMTypeInfo("ITriggerShape", sizeof(ITriggerShape), alignof(ITriggerShape), ITriggerShape::WriteJson, ITriggerShape::WriteSimpleJson, ITriggerShape::FromSimpleJson, ITriggerShape::Serialize, ITriggerShape::Equals);

void ITriggerShape::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ITriggerShape*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ITriggerShape::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ITriggerShape*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ITriggerShape::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ITriggerShape s_Object {};

	*reinterpret_cast<ITriggerShape*>(p_Target) = s_Object;
}

void ITriggerShape::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ITriggerShape*>(p_Object);

}

bool ITriggerShape::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ITriggerShape*>(p_Left);
	auto* s_Right = reinterpret_cast<ITriggerShape*>(p_Right);

	return *s_Left == *s_Right;
}

bool ITriggerShape::operator==(const ITriggerShape& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ITriggerShape>)
		return false;


	return true;
}

ZHMTypeInfo IValueEntity::TypeInfo = ZHMTypeInfo("IValueEntity", sizeof(IValueEntity), alignof(IValueEntity), IValueEntity::WriteJson, IValueEntity::WriteSimpleJson, IValueEntity::FromSimpleJson, IValueEntity::Serialize, IValueEntity::Equals);

void IValueEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IValueEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IValueEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IValueEntity s_Object {};

	*reinterpret_cast<IValueEntity*>(p_Target) = s_Object;
}

void IValueEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

}

bool IValueEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IValueEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IValueEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IValueEntity::operator==(const IValueEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IValueEntity>)
		return false;


	return true;
}

ZHMTypeInfo SActorSoundDefs::TypeInfo = ZHMTypeInfo("SActorSoundDefs", sizeof(SActorSoundDefs), alignof(SActorSoundDefs), SActorSoundDefs::WriteJson, SActorSoundDefs::WriteSimpleJson, SActorSoundDefs::FromSimpleJson, SActorSoundDefs::Serialize, SActorSoundDefs::Equals);

void SActorSoundDefs::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SActorSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SActorSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSoundDefs s_Object {};

	*reinterpret_cast<SActorSoundDefs*>(p_Target) = s_Object;
}

void SActorSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

}

bool SActorSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSoundDefs::operator==(const SActorSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSoundDefs>)
		return false;


	return true;
}

ZHMTypeInfo SBehaviorTreeEntityReference::TypeInfo = ZHMTypeInfo("SBehaviorTreeEntityReference", sizeof(SBehaviorTreeEntityReference), alignof(SBehaviorTreeEntityReference), SBehaviorTreeEntityReference::WriteJson, SBehaviorTreeEntityReference::WriteSimpleJson, SBehaviorTreeEntityReference::FromSimpleJson, SBehaviorTreeEntityReference::Serialize, SBehaviorTreeEntityReference::Equals);

void SBehaviorTreeEntityReference::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bList") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bList);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeEntityReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bList") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bList);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);

	p_Stream << "}";
}

void SBehaviorTreeEntityReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeEntityReference s_Object {};

	s_Object.m_bList = simdjson::from_json_bool(p_Document["m_bList"]);

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	*reinterpret_cast<SBehaviorTreeEntityReference*>(p_Target) = s_Object;
}

void SBehaviorTreeEntityReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEntityReference, m_sName));
}

bool SBehaviorTreeEntityReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEntityReference::operator==(const SBehaviorTreeEntityReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEntityReference>)
		return false;

	if (m_bList != p_Other.m_bList) return false;
	if (m_sName != p_Other.m_sName) return false;

	return true;
}

ZHMTypeInfo SBehaviorTreeEvaluationLogEntry::TypeInfo = ZHMTypeInfo("SBehaviorTreeEvaluationLogEntry", sizeof(SBehaviorTreeEvaluationLogEntry), alignof(SBehaviorTreeEvaluationLogEntry), SBehaviorTreeEvaluationLogEntry::WriteJson, SBehaviorTreeEvaluationLogEntry::WriteSimpleJson, SBehaviorTreeEvaluationLogEntry::FromSimpleJson, SBehaviorTreeEvaluationLogEntry::Serialize, SBehaviorTreeEvaluationLogEntry::Equals);

void SBehaviorTreeEvaluationLogEntry::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nBehaviorTreeIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBehaviorTreeIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nConditionOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nConditionOffset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bResult") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bResult);
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLogEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nBehaviorTreeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBehaviorTreeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nConditionOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nConditionOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bResult") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bResult);

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLogEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeEvaluationLogEntry s_Object {};

	s_Object.m_nBehaviorTreeIndex = simdjson::from_json_uint32(p_Document["m_nBehaviorTreeIndex"]);

	s_Object.m_nConditionOffset = simdjson::from_json_uint32(p_Document["m_nConditionOffset"]);

	s_Object.m_bResult = simdjson::from_json_bool(p_Document["m_bResult"]);

	*reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Target) = s_Object;
}

void SBehaviorTreeEvaluationLogEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

}

bool SBehaviorTreeEvaluationLogEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEvaluationLogEntry::operator==(const SBehaviorTreeEvaluationLogEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEvaluationLogEntry>)
		return false;

	if (m_nBehaviorTreeIndex != p_Other.m_nBehaviorTreeIndex) return false;
	if (m_nConditionOffset != p_Other.m_nConditionOffset) return false;
	if (m_bResult != p_Other.m_bResult) return false;

	return true;
}

ZHMTypeInfo ZResourceID::TypeInfo = ZHMTypeInfo("ZResourceID", sizeof(ZResourceID), alignof(ZResourceID), ZResourceID::WriteJson, ZResourceID::WriteSimpleJson, ZResourceID::FromSimpleJson, ZResourceID::Serialize, ZResourceID::Equals);

void ZResourceID::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_uri") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uri);
	p_Stream << "}";

	p_Stream << "}";
}

void ZResourceID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_uri") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uri);

	p_Stream << "}";
}

void ZResourceID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZResourceID s_Object {};

	s_Object.m_uri = std::string_view(p_Document["m_uri"]);

	*reinterpret_cast<ZResourceID*>(p_Target) = s_Object;
}

void ZResourceID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	ZString::Serialize(&s_Object->m_uri, p_Serializer, p_OwnOffset + offsetof(ZResourceID, m_uri));
}

bool ZResourceID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZResourceID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZResourceID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZResourceID::operator==(const ZResourceID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZResourceID>)
		return false;

	if (m_uri != p_Other.m_uri) return false;

	return true;
}

ZHMTypeInfo SBehaviorTreeEvaluationLog::TypeInfo = ZHMTypeInfo("SBehaviorTreeEvaluationLog", sizeof(SBehaviorTreeEvaluationLog), alignof(SBehaviorTreeEvaluationLog), SBehaviorTreeEvaluationLog::WriteJson, SBehaviorTreeEvaluationLog::WriteSimpleJson, SBehaviorTreeEvaluationLog::FromSimpleJson, SBehaviorTreeEvaluationLog::Serialize, SBehaviorTreeEvaluationLog::Equals);

void SBehaviorTreeEvaluationLog::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_BehaviorTrees") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZResourceID>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_BehaviorTrees.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_BehaviorTrees[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZResourceID") << ",\"$val\":";
		ZResourceID::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_BehaviorTrees.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Entries") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBehaviorTreeEvaluationLogEntry>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_Entries.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_Entries[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBehaviorTreeEvaluationLogEntry") << ",\"$val\":";
		SBehaviorTreeEvaluationLogEntry::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_Entries.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLog::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_BehaviorTrees") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_BehaviorTrees.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_BehaviorTrees[i];
		ZResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_BehaviorTrees.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Entries") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_Entries.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_Entries[i];
		SBehaviorTreeEvaluationLogEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_Entries.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLog::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeEvaluationLog s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_BehaviorTrees"];
	s_Object.m_BehaviorTrees.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZResourceID s_ArrayItem0;
		ZResourceID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_BehaviorTrees[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_Entries"];
	s_Object.m_Entries.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBehaviorTreeEvaluationLogEntry s_ArrayItem0;
		SBehaviorTreeEvaluationLogEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_Entries[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Target) = s_Object;
}

void SBehaviorTreeEvaluationLog::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	TArray<ZResourceID>::Serialize(&s_Object->m_BehaviorTrees, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEvaluationLog, m_BehaviorTrees));
	TArray<SBehaviorTreeEvaluationLogEntry>::Serialize(&s_Object->m_Entries, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEvaluationLog, m_Entries));
}

bool SBehaviorTreeEvaluationLog::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEvaluationLog::operator==(const SBehaviorTreeEvaluationLog& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEvaluationLog>)
		return false;

	if (m_BehaviorTrees != p_Other.m_BehaviorTrees) return false;
	if (m_Entries != p_Other.m_Entries) return false;

	return true;
}

ZHMTypeInfo SBehaviorTreeInputPinCondition::TypeInfo = ZHMTypeInfo("SBehaviorTreeInputPinCondition", sizeof(SBehaviorTreeInputPinCondition), alignof(SBehaviorTreeInputPinCondition), SBehaviorTreeInputPinCondition::WriteJson, SBehaviorTreeInputPinCondition::WriteSimpleJson, SBehaviorTreeInputPinCondition::FromSimpleJson, SBehaviorTreeInputPinCondition::Serialize, SBehaviorTreeInputPinCondition::Equals);

void SBehaviorTreeInputPinCondition::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeInputPinCondition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);

	p_Stream << "}";
}

void SBehaviorTreeInputPinCondition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeInputPinCondition s_Object {};

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	*reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Target) = s_Object;
}

void SBehaviorTreeInputPinCondition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInputPinCondition, m_sName));
}

bool SBehaviorTreeInputPinCondition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeInputPinCondition::operator==(const SBehaviorTreeInputPinCondition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeInputPinCondition>)
		return false;

	if (m_sName != p_Other.m_sName) return false;

	return true;
}

ZHMTypeInfo SBehaviorTreeInfo::TypeInfo = ZHMTypeInfo("SBehaviorTreeInfo", sizeof(SBehaviorTreeInfo), alignof(SBehaviorTreeInfo), SBehaviorTreeInfo::WriteJson, SBehaviorTreeInfo::WriteSimpleJson, SBehaviorTreeInfo::FromSimpleJson, SBehaviorTreeInfo::Serialize, SBehaviorTreeInfo::Equals);

void SBehaviorTreeInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_references") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBehaviorTreeEntityReference>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_references.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_references[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBehaviorTreeEntityReference") << ",\"$val\":";
		SBehaviorTreeEntityReference::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_references.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_inputPinConditions") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBehaviorTreeInputPinCondition>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_inputPinConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_inputPinConditions[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBehaviorTreeInputPinCondition") << ",\"$val\":";
		SBehaviorTreeInputPinCondition::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_inputPinConditions.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_references") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_references.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_references[i];
		SBehaviorTreeEntityReference::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_references.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_inputPinConditions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_inputPinConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_inputPinConditions[i];
		SBehaviorTreeInputPinCondition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_inputPinConditions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBehaviorTreeInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeInfo s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_references"];
	s_Object.m_references.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBehaviorTreeEntityReference s_ArrayItem0;
		SBehaviorTreeEntityReference::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_references[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_inputPinConditions"];
	s_Object.m_inputPinConditions.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBehaviorTreeInputPinCondition s_ArrayItem0;
		SBehaviorTreeInputPinCondition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_inputPinConditions[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SBehaviorTreeInfo*>(p_Target) = s_Object;
}

void SBehaviorTreeInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	TArray<SBehaviorTreeEntityReference>::Serialize(&s_Object->m_references, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInfo, m_references));
	TArray<SBehaviorTreeInputPinCondition>::Serialize(&s_Object->m_inputPinConditions, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInfo, m_inputPinConditions));
}

bool SBehaviorTreeInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeInfo::operator==(const SBehaviorTreeInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeInfo>)
		return false;

	if (m_references != p_Other.m_references) return false;
	if (m_inputPinConditions != p_Other.m_inputPinConditions) return false;

	return true;
}

ZHMTypeInfo SBodyPartDamageMultipliers::TypeInfo = ZHMTypeInfo("SBodyPartDamageMultipliers", sizeof(SBodyPartDamageMultipliers), alignof(SBodyPartDamageMultipliers), SBodyPartDamageMultipliers::WriteJson, SBodyPartDamageMultipliers::WriteSimpleJson, SBodyPartDamageMultipliers::FromSimpleJson, SBodyPartDamageMultipliers::Serialize, SBodyPartDamageMultipliers::Equals);

void SBodyPartDamageMultipliers::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fHeadDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeadDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fArmDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fArmDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHandDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHandDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLegDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLegDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTorsoDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTorsoDamageMultiplier);
	p_Stream << "}";

	p_Stream << "}";
}

void SBodyPartDamageMultipliers::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fHeadDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeadDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fArmDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fArmDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHandDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHandDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLegDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLegDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTorsoDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTorsoDamageMultiplier);

	p_Stream << "}";
}

void SBodyPartDamageMultipliers::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodyPartDamageMultipliers s_Object {};

	s_Object.m_fHeadDamageMultiplier = simdjson::from_json_float32(p_Document["m_fHeadDamageMultiplier"]);

	s_Object.m_fFaceDamageMultiplier = simdjson::from_json_float32(p_Document["m_fFaceDamageMultiplier"]);

	s_Object.m_fArmDamageMultiplier = simdjson::from_json_float32(p_Document["m_fArmDamageMultiplier"]);

	s_Object.m_fHandDamageMultiplier = simdjson::from_json_float32(p_Document["m_fHandDamageMultiplier"]);

	s_Object.m_fLegDamageMultiplier = simdjson::from_json_float32(p_Document["m_fLegDamageMultiplier"]);

	s_Object.m_fTorsoDamageMultiplier = simdjson::from_json_float32(p_Document["m_fTorsoDamageMultiplier"]);

	*reinterpret_cast<SBodyPartDamageMultipliers*>(p_Target) = s_Object;
}

void SBodyPartDamageMultipliers::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

}

bool SBodyPartDamageMultipliers::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyPartDamageMultipliers::operator==(const SBodyPartDamageMultipliers& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyPartDamageMultipliers>)
		return false;

	if (m_fHeadDamageMultiplier != p_Other.m_fHeadDamageMultiplier) return false;
	if (m_fFaceDamageMultiplier != p_Other.m_fFaceDamageMultiplier) return false;
	if (m_fArmDamageMultiplier != p_Other.m_fArmDamageMultiplier) return false;
	if (m_fHandDamageMultiplier != p_Other.m_fHandDamageMultiplier) return false;
	if (m_fLegDamageMultiplier != p_Other.m_fLegDamageMultiplier) return false;
	if (m_fTorsoDamageMultiplier != p_Other.m_fTorsoDamageMultiplier) return false;

	return true;
}

ZHMTypeInfo SVector3::TypeInfo = ZHMTypeInfo("SVector3", sizeof(SVector3), alignof(SVector3), SVector3::WriteJson, SVector3::WriteSimpleJson, SVector3::FromSimpleJson, SVector3::Serialize, SVector3::Equals);

void SVector3::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << "}";

	p_Stream << "}";
}

void SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);

	p_Stream << "}";
}

void SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVector3 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	s_Object.z = simdjson::from_json_float32(p_Document["z"]);

	*reinterpret_cast<SVector3*>(p_Target) = s_Object;
}

void SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

}

bool SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector3::operator==(const SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector3>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;

	return true;
}

ZHMTypeInfo SBoneScalesList::TypeInfo = ZHMTypeInfo("SBoneScalesList", sizeof(SBoneScalesList), alignof(SBoneScalesList), SBoneScalesList::WriteJson, SBoneScalesList::WriteSimpleJson, SBoneScalesList::FromSimpleJson, SBoneScalesList::Serialize, SBoneScalesList::Equals);

void SBoneScalesList::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aBoneScales") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SVector3>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneScales.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneScales[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
		SVector3::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aBoneScales.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SBoneScalesList::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBoneScales") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneScales.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneScales[i];
		SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBoneScales.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBoneScalesList::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBoneScalesList s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBoneScales"];
	s_Object.m_aBoneScales.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVector3 s_ArrayItem0;
		SVector3::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBoneScales[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SBoneScalesList*>(p_Target) = s_Object;
}

void SBoneScalesList::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	TArray<SVector3>::Serialize(&s_Object->m_aBoneScales, p_Serializer, p_OwnOffset + offsetof(SBoneScalesList, m_aBoneScales));
}

bool SBoneScalesList::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneScalesList*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneScalesList*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneScalesList::operator==(const SBoneScalesList& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneScalesList>)
		return false;

	if (m_aBoneScales != p_Other.m_aBoneScales) return false;

	return true;
}

ZHMTypeInfo SCPProgressionState::TypeInfo = ZHMTypeInfo("SCPProgressionState", sizeof(SCPProgressionState), alignof(SCPProgressionState), SCPProgressionState::WriteJson, SCPProgressionState::WriteSimpleJson, SCPProgressionState::FromSimpleJson, SCPProgressionState::Serialize, SCPProgressionState::Equals);

void SCPProgressionState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCPProgressionState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iCPIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCPIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iDifficulties") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iDifficulties);
	p_Stream << "}";

	p_Stream << "}";
}

void SCPProgressionState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCPProgressionState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iCPIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCPIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iDifficulties") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iDifficulties);

	p_Stream << "}";
}

void SCPProgressionState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCPProgressionState s_Object {};

	s_Object.m_iCPIndex = simdjson::from_json_int32(p_Document["m_iCPIndex"]);

	s_Object.m_iDifficulties = simdjson::from_json_uint32(p_Document["m_iDifficulties"]);

	*reinterpret_cast<SCPProgressionState*>(p_Target) = s_Object;
}

void SCPProgressionState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCPProgressionState*>(p_Object);

}

bool SCPProgressionState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCPProgressionState*>(p_Left);
	auto* s_Right = reinterpret_cast<SCPProgressionState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCPProgressionState::operator==(const SCPProgressionState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCPProgressionState>)
		return false;

	if (m_iCPIndex != p_Other.m_iCPIndex) return false;
	if (m_iDifficulties != p_Other.m_iDifficulties) return false;

	return true;
}

ZHMTypeInfo SSubGoalProgressData::TypeInfo = ZHMTypeInfo("SSubGoalProgressData", sizeof(SSubGoalProgressData), alignof(SSubGoalProgressData), SSubGoalProgressData::WriteJson, SSubGoalProgressData::WriteSimpleJson, SSubGoalProgressData::FromSimpleJson, SSubGoalProgressData::Serialize, SSubGoalProgressData::Equals);

void SSubGoalProgressData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSubGoalProgressData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nProgress") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nProgress);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNeeded") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNeeded);
	p_Stream << "}";

	p_Stream << "}";
}

void SSubGoalProgressData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSubGoalProgressData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nProgress") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nProgress);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNeeded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNeeded);

	p_Stream << "}";
}

void SSubGoalProgressData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSubGoalProgressData s_Object {};

	s_Object.m_nProgress = simdjson::from_json_int32(p_Document["m_nProgress"]);

	s_Object.m_nNeeded = simdjson::from_json_int32(p_Document["m_nNeeded"]);

	*reinterpret_cast<SSubGoalProgressData*>(p_Target) = s_Object;
}

void SSubGoalProgressData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSubGoalProgressData*>(p_Object);

}

bool SSubGoalProgressData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSubGoalProgressData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSubGoalProgressData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSubGoalProgressData::operator==(const SSubGoalProgressData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSubGoalProgressData>)
		return false;

	if (m_nProgress != p_Other.m_nProgress) return false;
	if (m_nNeeded != p_Other.m_nNeeded) return false;

	return true;
}

ZHMTypeInfo SFullGoalData::TypeInfo = ZHMTypeInfo("SFullGoalData", sizeof(SFullGoalData), alignof(SFullGoalData), SFullGoalData::WriteJson, SFullGoalData::WriteSimpleJson, SFullGoalData::FromSimpleJson, SFullGoalData::Serialize, SFullGoalData::Equals);

void SFullGoalData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFullGoalData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eLevelIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ELevelIndex") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eLevelIndex)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->m_eLevelIndex))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMessageText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EUIText") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eMessageText)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EUIText", static_cast<int>(s_Object->m_eMessageText))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eFriendMessageText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EUIText") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eFriendMessageText)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EUIText", static_cast<int>(s_Object->m_eFriendMessageText))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimestamp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTimestamp);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCategory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCategory);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasBeenSent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasBeenSent);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSecurityTapeChallenge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSecurityTapeChallenge);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTracked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTracked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompleted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHidden") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHidden);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLocked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLocked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SubgoalProgress") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SSubGoalProgressData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_SubgoalProgress.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_SubgoalProgress[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SSubGoalProgressData") << ",\"$val\":";
		SSubGoalProgressData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_SubgoalProgress.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SFullGoalData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFullGoalData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eLevelIndex") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->m_eLevelIndex)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMessageText") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EUIText", static_cast<int>(s_Object->m_eMessageText)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eFriendMessageText") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EUIText", static_cast<int>(s_Object->m_eFriendMessageText)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimestamp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTimestamp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasBeenSent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasBeenSent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSecurityTapeChallenge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSecurityTapeChallenge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTracked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTracked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLocked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLocked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SubgoalProgress") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_SubgoalProgress.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_SubgoalProgress[i];
		SSubGoalProgressData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_SubgoalProgress.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SFullGoalData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFullGoalData s_Object {};

	s_Object.m_eLevelIndex = static_cast<ELevelIndex>(ZHMEnums::GetEnumValueByName("ELevelIndex", std::string_view(p_Document["m_eLevelIndex"])));

	s_Object.m_nID = simdjson::from_json_int32(p_Document["m_nID"]);

	s_Object.m_eMessageText = static_cast<EUIText>(ZHMEnums::GetEnumValueByName("EUIText", std::string_view(p_Document["m_eMessageText"])));

	s_Object.m_eFriendMessageText = static_cast<EUIText>(ZHMEnums::GetEnumValueByName("EUIText", std::string_view(p_Document["m_eFriendMessageText"])));

	s_Object.m_nTimestamp = simdjson::from_json_int64(p_Document["m_nTimestamp"]);

	s_Object.m_nCategory = simdjson::from_json_int32(p_Document["m_nCategory"]);

	s_Object.m_bHasBeenSent = simdjson::from_json_bool(p_Document["m_bHasBeenSent"]);

	s_Object.m_bIsSecurityTapeChallenge = simdjson::from_json_bool(p_Document["m_bIsSecurityTapeChallenge"]);

	s_Object.m_bTracked = simdjson::from_json_bool(p_Document["m_bTracked"]);

	s_Object.m_bCompleted = simdjson::from_json_bool(p_Document["m_bCompleted"]);

	s_Object.m_bHidden = simdjson::from_json_bool(p_Document["m_bHidden"]);

	s_Object.m_bLocked = simdjson::from_json_bool(p_Document["m_bLocked"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_SubgoalProgress"];
	s_Object.m_SubgoalProgress.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSubGoalProgressData s_ArrayItem0;
		SSubGoalProgressData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_SubgoalProgress[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SFullGoalData*>(p_Target) = s_Object;
}

void SFullGoalData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFullGoalData*>(p_Object);

	TArray<SSubGoalProgressData>::Serialize(&s_Object->m_SubgoalProgress, p_Serializer, p_OwnOffset + offsetof(SFullGoalData, m_SubgoalProgress));
}

bool SFullGoalData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFullGoalData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFullGoalData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFullGoalData::operator==(const SFullGoalData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFullGoalData>)
		return false;

	if (m_eLevelIndex != p_Other.m_eLevelIndex) return false;
	if (m_nID != p_Other.m_nID) return false;
	if (m_eMessageText != p_Other.m_eMessageText) return false;
	if (m_eFriendMessageText != p_Other.m_eFriendMessageText) return false;
	if (m_nTimestamp != p_Other.m_nTimestamp) return false;
	if (m_nCategory != p_Other.m_nCategory) return false;
	if (m_bHasBeenSent != p_Other.m_bHasBeenSent) return false;
	if (m_bIsSecurityTapeChallenge != p_Other.m_bIsSecurityTapeChallenge) return false;
	if (m_bTracked != p_Other.m_bTracked) return false;
	if (m_bCompleted != p_Other.m_bCompleted) return false;
	if (m_bHidden != p_Other.m_bHidden) return false;
	if (m_bLocked != p_Other.m_bLocked) return false;
	if (m_SubgoalProgress != p_Other.m_SubgoalProgress) return false;

	return true;
}

ZHMTypeInfo SChallengeData::TypeInfo = ZHMTypeInfo("SChallengeData", sizeof(SChallengeData), alignof(SChallengeData), SChallengeData::WriteJson, SChallengeData::WriteSimpleJson, SChallengeData::FromSimpleJson, SChallengeData::Serialize, SChallengeData::Equals);

void SChallengeData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengeData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_FullGoalProgess") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SFullGoalData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_FullGoalProgess.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_FullGoalProgess[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SFullGoalData") << ",\"$val\":";
		SFullGoalData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_FullGoalProgess.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iLastUnlockedChallenge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iLastUnlockedChallenge);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iNumChallengesCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iNumChallengesCompleted);
	p_Stream << "}";

	p_Stream << "}";
}

void SChallengeData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengeData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_FullGoalProgess") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_FullGoalProgess.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_FullGoalProgess[i];
		SFullGoalData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_FullGoalProgess.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iLastUnlockedChallenge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iLastUnlockedChallenge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iNumChallengesCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iNumChallengesCompleted);

	p_Stream << "}";
}

void SChallengeData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SChallengeData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_FullGoalProgess"];
	s_Object.m_FullGoalProgess.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SFullGoalData s_ArrayItem0;
		SFullGoalData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_FullGoalProgess[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_iLastUnlockedChallenge = simdjson::from_json_int32(p_Document["m_iLastUnlockedChallenge"]);

	s_Object.m_iNumChallengesCompleted = simdjson::from_json_int32(p_Document["m_iNumChallengesCompleted"]);

	*reinterpret_cast<SChallengeData*>(p_Target) = s_Object;
}

void SChallengeData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChallengeData*>(p_Object);

	TArray<SFullGoalData>::Serialize(&s_Object->m_FullGoalProgess, p_Serializer, p_OwnOffset + offsetof(SChallengeData, m_FullGoalProgess));
}

bool SChallengeData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChallengeData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChallengeData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChallengeData::operator==(const SChallengeData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChallengeData>)
		return false;

	if (m_FullGoalProgess != p_Other.m_FullGoalProgess) return false;
	if (m_iLastUnlockedChallenge != p_Other.m_iLastUnlockedChallenge) return false;
	if (m_iNumChallengesCompleted != p_Other.m_iNumChallengesCompleted) return false;

	return true;
}

ZHMTypeInfo SCheatData::TypeInfo = ZHMTypeInfo("SCheatData", sizeof(SCheatData), alignof(SCheatData), SCheatData::WriteJson, SCheatData::WriteSimpleJson, SCheatData::FromSimpleJson, SCheatData::Serialize, SCheatData::Equals);

void SCheatData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCheatData*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SCheatData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCheatData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SCheatData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCheatData s_Object {};

	*reinterpret_cast<SCheatData*>(p_Target) = s_Object;
}

void SCheatData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCheatData*>(p_Object);

}

bool SCheatData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCheatData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCheatData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCheatData::operator==(const SCheatData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCheatData>)
		return false;


	return true;
}

ZHMTypeInfo STokenID::TypeInfo = ZHMTypeInfo("STokenID", sizeof(STokenID), alignof(STokenID), STokenID::WriteJson, STokenID::WriteSimpleJson, STokenID::FromSimpleJson, STokenID::Serialize, STokenID::Equals);

void STokenID::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValid);
	p_Stream << "}";

	p_Stream << "}";
}

void STokenID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValid);

	p_Stream << "}";
}

void STokenID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STokenID s_Object {};

	s_Object.m_iValue = simdjson::from_json_uint32(p_Document["m_iValue"]);

	s_Object.m_bValid = simdjson::from_json_bool(p_Document["m_bValid"]);

	*reinterpret_cast<STokenID*>(p_Target) = s_Object;
}

void STokenID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

}

bool STokenID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STokenID*>(p_Left);
	auto* s_Right = reinterpret_cast<STokenID*>(p_Right);

	return *s_Left == *s_Right;
}

bool STokenID::operator==(const STokenID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STokenID>)
		return false;

	if (m_iValue != p_Other.m_iValue) return false;
	if (m_bValid != p_Other.m_bValid) return false;

	return true;
}

ZHMTypeInfo SCloseCombatWeaponSaveData::TypeInfo = ZHMTypeInfo("SCloseCombatWeaponSaveData", sizeof(SCloseCombatWeaponSaveData), alignof(SCloseCombatWeaponSaveData), SCloseCombatWeaponSaveData::WriteJson, SCloseCombatWeaponSaveData::WriteSimpleJson, SCloseCombatWeaponSaveData::FromSimpleJson, SCloseCombatWeaponSaveData::Serialize, SCloseCombatWeaponSaveData::Equals);

void SCloseCombatWeaponSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCloseCombatWeaponSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_ID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STokenID") << ",\"$val\":";
	STokenID::WriteJson(&s_Object->m_ID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nImpactCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nImpactCount);
	p_Stream << "}";

	p_Stream << "}";
}

void SCloseCombatWeaponSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCloseCombatWeaponSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_ID") << ":";
	STokenID::WriteSimpleJson(&s_Object->m_ID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nImpactCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nImpactCount);

	p_Stream << "}";
}

void SCloseCombatWeaponSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCloseCombatWeaponSaveData s_Object {};

	{
		STokenID s_Item {};
		STokenID::FromSimpleJson(p_Document["m_ID"], &s_Item);
		s_Object.m_ID = s_Item;
	}

	s_Object.m_nImpactCount = simdjson::from_json_int32(p_Document["m_nImpactCount"]);

	*reinterpret_cast<SCloseCombatWeaponSaveData*>(p_Target) = s_Object;
}

void SCloseCombatWeaponSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCloseCombatWeaponSaveData*>(p_Object);

	STokenID::Serialize(&s_Object->m_ID, p_Serializer, p_OwnOffset + offsetof(SCloseCombatWeaponSaveData, m_ID));
}

bool SCloseCombatWeaponSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCloseCombatWeaponSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCloseCombatWeaponSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCloseCombatWeaponSaveData::operator==(const SCloseCombatWeaponSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCloseCombatWeaponSaveData>)
		return false;

	if (m_ID != p_Other.m_ID) return false;
	if (m_nImpactCount != p_Other.m_nImpactCount) return false;

	return true;
}

ZHMTypeInfo SItemSaveData::TypeInfo = ZHMTypeInfo("SItemSaveData", sizeof(SItemSaveData), alignof(SItemSaveData), SItemSaveData::WriteJson, SItemSaveData::WriteSimpleJson, SItemSaveData::FromSimpleJson, SItemSaveData::Serialize, SItemSaveData::Equals);

void SItemSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_ID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STokenID") << ",\"$val\":";
	STokenID::WriteJson(&s_Object->m_ID, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_ID") << ":";
	STokenID::WriteSimpleJson(&s_Object->m_ID, p_Stream);

	p_Stream << "}";
}

void SItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemSaveData s_Object {};

	{
		STokenID s_Item {};
		STokenID::FromSimpleJson(p_Document["m_ID"], &s_Item);
		s_Object.m_ID = s_Item;
	}

	*reinterpret_cast<SItemSaveData*>(p_Target) = s_Object;
}

void SItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	STokenID::Serialize(&s_Object->m_ID, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_ID));
}

bool SItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemSaveData::operator==(const SItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemSaveData>)
		return false;

	if (m_ID != p_Other.m_ID) return false;

	return true;
}

ZHMTypeInfo SRangedWeaponSaveData::TypeInfo = ZHMTypeInfo("SRangedWeaponSaveData", sizeof(SRangedWeaponSaveData), alignof(SRangedWeaponSaveData), SRangedWeaponSaveData::WriteJson, SRangedWeaponSaveData::WriteSimpleJson, SRangedWeaponSaveData::FromSimpleJson, SRangedWeaponSaveData::Serialize, SRangedWeaponSaveData::Equals);

void SRangedWeaponSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRangedWeaponSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_ID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STokenID") << ",\"$val\":";
	STokenID::WriteJson(&s_Object->m_ID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBulletsInMagazine") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBulletsInMagazine);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAltFire") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAltFire);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aUpgradesState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aUpgradesState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aUpgradesState[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aUpgradesState.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SRangedWeaponSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRangedWeaponSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_ID") << ":";
	STokenID::WriteSimpleJson(&s_Object->m_ID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBulletsInMagazine") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBulletsInMagazine);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAltFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAltFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aUpgradesState") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aUpgradesState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aUpgradesState[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aUpgradesState.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SRangedWeaponSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRangedWeaponSaveData s_Object {};

	{
		STokenID s_Item {};
		STokenID::FromSimpleJson(p_Document["m_ID"], &s_Item);
		s_Object.m_ID = s_Item;
	}

	s_Object.m_nBulletsInMagazine = simdjson::from_json_int32(p_Document["m_nBulletsInMagazine"]);

	s_Object.m_bAltFire = simdjson::from_json_bool(p_Document["m_bAltFire"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aUpgradesState"];
	s_Object.m_aUpgradesState.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aUpgradesState[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	*reinterpret_cast<SRangedWeaponSaveData*>(p_Target) = s_Object;
}

void SRangedWeaponSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRangedWeaponSaveData*>(p_Object);

	STokenID::Serialize(&s_Object->m_ID, p_Serializer, p_OwnOffset + offsetof(SRangedWeaponSaveData, m_ID));
	TArray<bool>::Serialize(&s_Object->m_aUpgradesState, p_Serializer, p_OwnOffset + offsetof(SRangedWeaponSaveData, m_aUpgradesState));
}

bool SRangedWeaponSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRangedWeaponSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRangedWeaponSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRangedWeaponSaveData::operator==(const SRangedWeaponSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRangedWeaponSaveData>)
		return false;

	if (m_ID != p_Other.m_ID) return false;
	if (m_nBulletsInMagazine != p_Other.m_nBulletsInMagazine) return false;
	if (m_bAltFire != p_Other.m_bAltFire) return false;
	if (m_aUpgradesState != p_Other.m_aUpgradesState) return false;

	return true;
}

ZHMTypeInfo SCheckpointSaveData::TypeInfo = ZHMTypeInfo("SCheckpointSaveData", sizeof(SCheckpointSaveData), alignof(SCheckpointSaveData), SCheckpointSaveData::WriteJson, SCheckpointSaveData::WriteSimpleJson, SCheckpointSaveData::FromSimpleJson, SCheckpointSaveData::Serialize, SCheckpointSaveData::Equals);

void SCheckpointSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCheckpointSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iCheckpointCompoundID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCheckpointCompoundID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLocked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLocked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompleted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitTokenID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STokenID") << ",\"$val\":";
	STokenID::WriteJson(&s_Object->m_OutfitTokenID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoInPocket") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TFixedArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_nAmmoInPocket.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_nAmmoInPocket[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_nAmmoInPocket.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocus") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocus);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHealth") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHealth);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BoolValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_BoolValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_BoolValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_BoolValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_FloatValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<float32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_FloatValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_FloatValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_FloatValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Items") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SItemSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_Items.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_Items[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SItemSaveData") << ",\"$val\":";
		SItemSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_Items.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RangedWeapons") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SRangedWeaponSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_RangedWeapons.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_RangedWeapons[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SRangedWeaponSaveData") << ",\"$val\":";
		SRangedWeaponSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_RangedWeapons.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CloseCombatdWeapons") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCloseCombatWeaponSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CloseCombatdWeapons.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CloseCombatdWeapons[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCloseCombatWeaponSaveData") << ",\"$val\":";
		SCloseCombatWeaponSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_CloseCombatdWeapons.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iInventorySlot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iInventorySlot);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInventoryDualWield") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInventoryDualWield);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInventoryUnholstered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInventoryUnholstered);
	p_Stream << "}";

	p_Stream << "}";
}

void SCheckpointSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCheckpointSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iCheckpointCompoundID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCheckpointCompoundID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLocked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLocked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitTokenID") << ":";
	STokenID::WriteSimpleJson(&s_Object->m_OutfitTokenID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoInPocket") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_nAmmoInPocket.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_nAmmoInPocket[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_nAmmoInPocket.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocus") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocus);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHealth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHealth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BoolValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_BoolValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_BoolValues[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_BoolValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_FloatValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_FloatValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_FloatValues[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_FloatValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Items") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_Items.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_Items[i];
		SItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_Items.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RangedWeapons") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_RangedWeapons.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_RangedWeapons[i];
		SRangedWeaponSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_RangedWeapons.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CloseCombatdWeapons") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CloseCombatdWeapons.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CloseCombatdWeapons[i];
		SCloseCombatWeaponSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CloseCombatdWeapons.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iInventorySlot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iInventorySlot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInventoryDualWield") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInventoryDualWield);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInventoryUnholstered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInventoryUnholstered);

	p_Stream << "}";
}

void SCheckpointSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCheckpointSaveData s_Object {};

	s_Object.m_iCheckpointCompoundID = simdjson::from_json_int32(p_Document["m_iCheckpointCompoundID"]);

	s_Object.m_bLocked = simdjson::from_json_bool(p_Document["m_bLocked"]);

	s_Object.m_bCompleted = simdjson::from_json_bool(p_Document["m_bCompleted"]);

	{
		STokenID s_Item {};
		STokenID::FromSimpleJson(p_Document["m_OutfitTokenID"], &s_Item);
		s_Object.m_OutfitTokenID = s_Item;
	}

	s_Object.m_nOutfitVariation = simdjson::from_json_int32(p_Document["m_nOutfitVariation"]);

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_nAmmoInPocket"])
	{
		s_Object.m_nAmmoInPocket[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	s_Object.m_fFocus = simdjson::from_json_float32(p_Document["m_fFocus"]);

	s_Object.m_fHealth = simdjson::from_json_float32(p_Document["m_fHealth"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_BoolValues"];
	s_Object.m_BoolValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_BoolValues[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_FloatValues"];
	s_Object.m_FloatValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_FloatValues[s_Index0++] = simdjson::from_json_float32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_Items"];
	s_Object.m_Items.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SItemSaveData s_ArrayItem0;
		SItemSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_Items[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_RangedWeapons"];
	s_Object.m_RangedWeapons.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SRangedWeaponSaveData s_ArrayItem0;
		SRangedWeaponSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_RangedWeapons[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CloseCombatdWeapons"];
	s_Object.m_CloseCombatdWeapons.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCloseCombatWeaponSaveData s_ArrayItem0;
		SCloseCombatWeaponSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_CloseCombatdWeapons[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_iInventorySlot = simdjson::from_json_int32(p_Document["m_iInventorySlot"]);

	s_Object.m_bInventoryDualWield = simdjson::from_json_bool(p_Document["m_bInventoryDualWield"]);

	s_Object.m_bInventoryUnholstered = simdjson::from_json_bool(p_Document["m_bInventoryUnholstered"]);

	*reinterpret_cast<SCheckpointSaveData*>(p_Target) = s_Object;
}

void SCheckpointSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCheckpointSaveData*>(p_Object);

	STokenID::Serialize(&s_Object->m_OutfitTokenID, p_Serializer, p_OwnOffset + offsetof(SCheckpointSaveData, m_OutfitTokenID));
	TFixedArray<uint32, 8>::Serialize(&s_Object->m_nAmmoInPocket, p_Serializer, p_OwnOffset + offsetof(SCheckpointSaveData, m_nAmmoInPocket));
	TArray<bool>::Serialize(&s_Object->m_BoolValues, p_Serializer, p_OwnOffset + offsetof(SCheckpointSaveData, m_BoolValues));
	TArray<float32>::Serialize(&s_Object->m_FloatValues, p_Serializer, p_OwnOffset + offsetof(SCheckpointSaveData, m_FloatValues));
	TArray<SItemSaveData>::Serialize(&s_Object->m_Items, p_Serializer, p_OwnOffset + offsetof(SCheckpointSaveData, m_Items));
	TArray<SRangedWeaponSaveData>::Serialize(&s_Object->m_RangedWeapons, p_Serializer, p_OwnOffset + offsetof(SCheckpointSaveData, m_RangedWeapons));
	TArray<SCloseCombatWeaponSaveData>::Serialize(&s_Object->m_CloseCombatdWeapons, p_Serializer, p_OwnOffset + offsetof(SCheckpointSaveData, m_CloseCombatdWeapons));
}

bool SCheckpointSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCheckpointSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCheckpointSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCheckpointSaveData::operator==(const SCheckpointSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCheckpointSaveData>)
		return false;

	if (m_iCheckpointCompoundID != p_Other.m_iCheckpointCompoundID) return false;
	if (m_bLocked != p_Other.m_bLocked) return false;
	if (m_bCompleted != p_Other.m_bCompleted) return false;
	if (m_OutfitTokenID != p_Other.m_OutfitTokenID) return false;
	if (m_nOutfitVariation != p_Other.m_nOutfitVariation) return false;
	if (m_nAmmoInPocket != p_Other.m_nAmmoInPocket) return false;
	if (m_fFocus != p_Other.m_fFocus) return false;
	if (m_fHealth != p_Other.m_fHealth) return false;
	if (m_BoolValues != p_Other.m_BoolValues) return false;
	if (m_FloatValues != p_Other.m_FloatValues) return false;
	if (m_Items != p_Other.m_Items) return false;
	if (m_RangedWeapons != p_Other.m_RangedWeapons) return false;
	if (m_CloseCombatdWeapons != p_Other.m_CloseCombatdWeapons) return false;
	if (m_iInventorySlot != p_Other.m_iInventorySlot) return false;
	if (m_bInventoryDualWield != p_Other.m_bInventoryDualWield) return false;
	if (m_bInventoryUnholstered != p_Other.m_bInventoryUnholstered) return false;

	return true;
}

ZHMTypeInfo float4::TypeInfo = ZHMTypeInfo("float4", sizeof(float4), alignof(float4), float4::WriteJson, float4::WriteSimpleJson, float4::FromSimpleJson, float4::Serialize, float4::Equals);

void float4::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->w);
	p_Stream << "}";

	p_Stream << "}";
}

void float4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << simdjson::as_json_string(s_Object->w);

	p_Stream << "}";
}

void float4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	float4 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	s_Object.z = simdjson::from_json_float32(p_Document["z"]);

	s_Object.w = simdjson::from_json_float32(p_Document["w"]);

	*reinterpret_cast<float4*>(p_Target) = s_Object;
}

void float4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

}

bool float4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<float4*>(p_Left);
	auto* s_Right = reinterpret_cast<float4*>(p_Right);

	return *s_Left == *s_Right;
}

bool float4::operator==(const float4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<float4>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;
	if (w != p_Other.w) return false;

	return true;
}

ZHMTypeInfo SCollidingParticle::TypeInfo = ZHMTypeInfo("SCollidingParticle", sizeof(SCollidingParticle), alignof(SCollidingParticle), SCollidingParticle::WriteJson, SCollidingParticle::WriteSimpleJson, SCollidingParticle::FromSimpleJson, SCollidingParticle::Serialize, SCollidingParticle::Equals);

void SCollidingParticle::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nColor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSize);
	p_Stream << "}";

	p_Stream << "}";
}

void SCollidingParticle::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nColor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSize);

	p_Stream << "}";
}

void SCollidingParticle::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCollidingParticle s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vVelocity"], &s_Item);
		s_Object.m_vVelocity = s_Item;
	}

	s_Object.m_nColor = simdjson::from_json_uint32(p_Document["m_nColor"]);

	s_Object.m_fSize = simdjson::from_json_float32(p_Document["m_fSize"]);

	*reinterpret_cast<SCollidingParticle*>(p_Target) = s_Object;
}

void SCollidingParticle::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vPosition));
	float4::Serialize(&s_Object->m_vVelocity, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vVelocity));
}

bool SCollidingParticle::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollidingParticle*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollidingParticle*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollidingParticle::operator==(const SCollidingParticle& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollidingParticle>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vVelocity != p_Other.m_vVelocity) return false;
	if (m_nColor != p_Other.m_nColor) return false;
	if (m_fSize != p_Other.m_fSize) return false;

	return true;
}

ZHMTypeInfo SColorRGB::TypeInfo = ZHMTypeInfo("SColorRGB", sizeof(SColorRGB), alignof(SColorRGB), SColorRGB::WriteJson, SColorRGB::WriteSimpleJson, SColorRGB::FromSimpleJson, SColorRGB::Serialize, SColorRGB::Equals);

void SColorRGB::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->b);
	p_Stream << "}";

	p_Stream << "}";
}

void SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->b);

	p_Stream << "}";
}

void SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SColorRGB s_Object {};

	s_Object.r = simdjson::from_json_float32(p_Document["r"]);

	s_Object.g = simdjson::from_json_float32(p_Document["g"]);

	s_Object.b = simdjson::from_json_float32(p_Document["b"]);

	*reinterpret_cast<SColorRGB*>(p_Target) = s_Object;
}

void SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

}

bool SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGB::operator==(const SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGB>)
		return false;

	if (r != p_Other.r) return false;
	if (g != p_Other.g) return false;
	if (b != p_Other.b) return false;

	return true;
}

ZHMTypeInfo SColorRGBA::TypeInfo = ZHMTypeInfo("SColorRGBA", sizeof(SColorRGBA), alignof(SColorRGBA), SColorRGBA::WriteJson, SColorRGBA::WriteSimpleJson, SColorRGBA::FromSimpleJson, SColorRGBA::Serialize, SColorRGBA::Equals);

void SColorRGBA::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->b);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("a") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->a);
	p_Stream << "}";

	p_Stream << "}";
}

void SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->b);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("a") << ":";
	p_Stream << simdjson::as_json_string(s_Object->a);

	p_Stream << "}";
}

void SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SColorRGBA s_Object {};

	s_Object.r = simdjson::from_json_float32(p_Document["r"]);

	s_Object.g = simdjson::from_json_float32(p_Document["g"]);

	s_Object.b = simdjson::from_json_float32(p_Document["b"]);

	s_Object.a = simdjson::from_json_float32(p_Document["a"]);

	*reinterpret_cast<SColorRGBA*>(p_Target) = s_Object;
}

void SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

}

bool SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGBA::operator==(const SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGBA>)
		return false;

	if (r != p_Other.r) return false;
	if (g != p_Other.g) return false;
	if (b != p_Other.b) return false;
	if (a != p_Other.a) return false;

	return true;
}

ZHMTypeInfo ZBehaviorTreeVariable::TypeInfo = ZHMTypeInfo("ZBehaviorTreeVariable", sizeof(ZBehaviorTreeVariable), alignof(ZBehaviorTreeVariable), ZBehaviorTreeVariable::WriteJson, ZBehaviorTreeVariable::WriteSimpleJson, ZBehaviorTreeVariable::FromSimpleJson, ZBehaviorTreeVariable::Serialize, ZBehaviorTreeVariable::Equals);

void ZBehaviorTreeVariable::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZBehaviorTreeVariable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZBehaviorTreeVariable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZBehaviorTreeVariable s_Object {};

	*reinterpret_cast<ZBehaviorTreeVariable*>(p_Target) = s_Object;
}

void ZBehaviorTreeVariable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

}

bool ZBehaviorTreeVariable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZBehaviorTreeVariable*>(p_Left);
	auto* s_Right = reinterpret_cast<ZBehaviorTreeVariable*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZBehaviorTreeVariable::operator==(const ZBehaviorTreeVariable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZBehaviorTreeVariable>)
		return false;


	return true;
}

ZHMTypeInfo SConditionBase::TypeInfo = ZHMTypeInfo("SConditionBase", sizeof(SConditionBase), alignof(SConditionBase), SConditionBase::WriteJson, SConditionBase::WriteSimpleJson, SConditionBase::FromSimpleJson, SConditionBase::Serialize, SConditionBase::Equals);

void SConditionBase::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("eConditionType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ECompiledConditionType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->eConditionType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECompiledConditionType", static_cast<int>(s_Object->eConditionType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nConditionModifiers") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nConditionModifiers);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("assignTo") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZBehaviorTreeVariable") << ",\"$val\":";
	ZBehaviorTreeVariable::WriteJson(&s_Object->assignTo, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SConditionBase::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("eConditionType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECompiledConditionType", static_cast<int>(s_Object->eConditionType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nConditionModifiers") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nConditionModifiers);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("assignTo") << ":";
	ZBehaviorTreeVariable::WriteSimpleJson(&s_Object->assignTo, p_Stream);

	p_Stream << "}";
}

void SConditionBase::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SConditionBase s_Object {};

	s_Object.eConditionType = static_cast<ECompiledConditionType>(ZHMEnums::GetEnumValueByName("ECompiledConditionType", std::string_view(p_Document["eConditionType"])));

	s_Object.nConditionModifiers = simdjson::from_json_uint32(p_Document["nConditionModifiers"]);

	{
		ZBehaviorTreeVariable s_Item {};
		ZBehaviorTreeVariable::FromSimpleJson(p_Document["assignTo"], &s_Item);
		s_Object.assignTo = s_Item;
	}

	*reinterpret_cast<SConditionBase*>(p_Target) = s_Object;
}

void SConditionBase::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	ZBehaviorTreeVariable::Serialize(&s_Object->assignTo, p_Serializer, p_OwnOffset + offsetof(SConditionBase, assignTo));
}

bool SConditionBase::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SConditionBase*>(p_Left);
	auto* s_Right = reinterpret_cast<SConditionBase*>(p_Right);

	return *s_Left == *s_Right;
}

bool SConditionBase::operator==(const SConditionBase& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SConditionBase>)
		return false;

	if (eConditionType != p_Other.eConditionType) return false;
	if (nConditionModifiers != p_Other.nConditionModifiers) return false;
	if (assignTo != p_Other.assignTo) return false;

	return true;
}

ZHMTypeInfo SContentKitBaseState::TypeInfo = ZHMTypeInfo("SContentKitBaseState", sizeof(SContentKitBaseState), alignof(SContentKitBaseState), SContentKitBaseState::WriteJson, SContentKitBaseState::WriteSimpleJson, SContentKitBaseState::FromSimpleJson, SContentKitBaseState::Serialize, SContentKitBaseState::Equals);

void SContentKitBaseState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContentKitBaseState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iKitState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iKitState);
	p_Stream << "}";

	p_Stream << "}";
}

void SContentKitBaseState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContentKitBaseState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iKitState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iKitState);

	p_Stream << "}";
}

void SContentKitBaseState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContentKitBaseState s_Object {};

	s_Object.m_iKitState = simdjson::from_json_uint8(p_Document["m_iKitState"]);

	*reinterpret_cast<SContentKitBaseState*>(p_Target) = s_Object;
}

void SContentKitBaseState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContentKitBaseState*>(p_Object);

}

bool SContentKitBaseState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContentKitBaseState*>(p_Left);
	auto* s_Right = reinterpret_cast<SContentKitBaseState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContentKitBaseState::operator==(const SContentKitBaseState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContentKitBaseState>)
		return false;

	if (m_iKitState != p_Other.m_iKitState) return false;

	return true;
}

ZHMTypeInfo SContractUnlockStatus::TypeInfo = ZHMTypeInfo("SContractUnlockStatus", sizeof(SContractUnlockStatus), alignof(SContractUnlockStatus), SContractUnlockStatus::WriteJson, SContractUnlockStatus::WriteSimpleJson, SContractUnlockStatus::FromSimpleJson, SContractUnlockStatus::Serialize, SContractUnlockStatus::Equals);

void SContractUnlockStatus::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractUnlockStatus*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("bUnlocked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bUnlocked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eLevelIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ELevelIndex") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->eLevelIndex)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->eLevelIndex))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iContractIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->iContractIndex);
	p_Stream << "}";

	p_Stream << "}";
}

void SContractUnlockStatus::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractUnlockStatus*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("bUnlocked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bUnlocked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eLevelIndex") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->eLevelIndex)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iContractIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iContractIndex);

	p_Stream << "}";
}

void SContractUnlockStatus::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractUnlockStatus s_Object {};

	s_Object.bUnlocked = simdjson::from_json_bool(p_Document["bUnlocked"]);

	s_Object.eLevelIndex = static_cast<ELevelIndex>(ZHMEnums::GetEnumValueByName("ELevelIndex", std::string_view(p_Document["eLevelIndex"])));

	s_Object.iContractIndex = simdjson::from_json_int32(p_Document["iContractIndex"]);

	*reinterpret_cast<SContractUnlockStatus*>(p_Target) = s_Object;
}

void SContractUnlockStatus::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractUnlockStatus*>(p_Object);

}

bool SContractUnlockStatus::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractUnlockStatus*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractUnlockStatus*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractUnlockStatus::operator==(const SContractUnlockStatus& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractUnlockStatus>)
		return false;

	if (bUnlocked != p_Other.bUnlocked) return false;
	if (eLevelIndex != p_Other.eLevelIndex) return false;
	if (iContractIndex != p_Other.iContractIndex) return false;

	return true;
}

ZHMTypeInfo SContractSaveData::TypeInfo = ZHMTypeInfo("SContractSaveData", sizeof(SContractSaveData), alignof(SContractSaveData), SContractSaveData::WriteJson, SContractSaveData::WriteSimpleJson, SContractSaveData::FromSimpleJson, SContractSaveData::Serialize, SContractSaveData::Equals);

void SContractSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("bTutorialPlayed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bTutorialPlayed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aLocalContractUnlockStatusData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SContractUnlockStatus>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aLocalContractUnlockStatusData.size(); ++i)
	{
		auto& s_Item0 = s_Object->aLocalContractUnlockStatusData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SContractUnlockStatus") << ",\"$val\":";
		SContractUnlockStatus::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->aLocalContractUnlockStatusData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SContractSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("bTutorialPlayed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bTutorialPlayed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aLocalContractUnlockStatusData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aLocalContractUnlockStatusData.size(); ++i)
	{
		auto& s_Item0 = s_Object->aLocalContractUnlockStatusData[i];
		SContractUnlockStatus::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aLocalContractUnlockStatusData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SContractSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractSaveData s_Object {};

	s_Object.bTutorialPlayed = simdjson::from_json_bool(p_Document["bTutorialPlayed"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aLocalContractUnlockStatusData"];
	s_Object.aLocalContractUnlockStatusData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SContractUnlockStatus s_ArrayItem0;
		SContractUnlockStatus::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aLocalContractUnlockStatusData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SContractSaveData*>(p_Target) = s_Object;
}

void SContractSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractSaveData*>(p_Object);

	TArray<SContractUnlockStatus>::Serialize(&s_Object->aLocalContractUnlockStatusData, p_Serializer, p_OwnOffset + offsetof(SContractSaveData, aLocalContractUnlockStatusData));
}

bool SContractSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractSaveData::operator==(const SContractSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractSaveData>)
		return false;

	if (bTutorialPlayed != p_Other.bTutorialPlayed) return false;
	if (aLocalContractUnlockStatusData != p_Other.aLocalContractUnlockStatusData) return false;

	return true;
}

ZHMTypeInfo SEntityTemplateProperty::TypeInfo = ZHMTypeInfo("SEntityTemplateProperty", sizeof(SEntityTemplateProperty), alignof(SEntityTemplateProperty), SEntityTemplateProperty::WriteJson, SEntityTemplateProperty::WriteSimpleJson, SEntityTemplateProperty::FromSimpleJson, SEntityTemplateProperty::Serialize, SEntityTemplateProperty::Equals);

void SEntityTemplateProperty::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("nPropertyID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nPropertyID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->value, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplateProperty::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nPropertyID") << ":";
	{
		auto s_PropertyName = ZHMProperties::PropertyToString(s_Object->nPropertyID);

		if (s_PropertyName.size() == 0)
			p_Stream << simdjson::as_json_string(s_Object->nPropertyID);
		else
			p_Stream << simdjson::as_json_string(s_PropertyName);
	}
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->value, p_Stream);

	p_Stream << "}";
}

void SEntityTemplateProperty::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateProperty s_Object {};

	if (p_Document["nPropertyID"].type() == simdjson::ondemand::json_type::string)
		s_Object.nPropertyID = Hash::Crc32(std::string_view(p_Document["nPropertyID"]));
	else
		s_Object.nPropertyID = simdjson::from_json_uint32(p_Document["nPropertyID"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["value"], &s_Item);
		s_Object.value = s_Item;
	}

	*reinterpret_cast<SEntityTemplateProperty*>(p_Target) = s_Object;
}

void SEntityTemplateProperty::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	ZVariant::Serialize(&s_Object->value, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateProperty, value));
}

bool SEntityTemplateProperty::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateProperty*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateProperty*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateProperty::operator==(const SEntityTemplateProperty& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateProperty>)
		return false;

	if (nPropertyID != p_Other.nPropertyID) return false;
	if (value != p_Other.value) return false;

	return true;
}

ZHMTypeInfo SCppEntity::TypeInfo = ZHMTypeInfo("SCppEntity", sizeof(SCppEntity), alignof(SCppEntity), SCppEntity::WriteJson, SCppEntity::WriteSimpleJson, SCppEntity::FromSimpleJson, SCppEntity::Serialize, SCppEntity::Equals);

void SCppEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplateProperty>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateProperty") << ",\"$val\":";
		SEntityTemplateProperty::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCppEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCppEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntity s_Object {};

	s_Object.blueprintIndexInResourceHeader = simdjson::from_json_int32(p_Document["blueprintIndexInResourceHeader"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyValues"];
	s_Object.propertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyValues[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCppEntity*>(p_Target) = s_Object;
}

void SCppEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	TArray<SEntityTemplateProperty>::Serialize(&s_Object->propertyValues, p_Serializer, p_OwnOffset + offsetof(SCppEntity, propertyValues));
}

bool SCppEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntity::operator==(const SCppEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntity>)
		return false;

	if (blueprintIndexInResourceHeader != p_Other.blueprintIndexInResourceHeader) return false;
	if (propertyValues != p_Other.propertyValues) return false;

	return true;
}

ZHMTypeInfo SCppEntitySubsetInfo::TypeInfo = ZHMTypeInfo("SCppEntitySubsetInfo", sizeof(SCppEntitySubsetInfo), alignof(SCppEntitySubsetInfo), SCppEntitySubsetInfo::WriteJson, SCppEntitySubsetInfo::WriteSimpleJson, SCppEntitySubsetInfo::FromSimpleJson, SCppEntitySubsetInfo::Serialize, SCppEntitySubsetInfo::Equals);

void SCppEntitySubsetInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("name") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->name);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TypeID") << ",\"$val\":";
	TypeID::WriteJson(&s_Object->type, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("flags") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->flags);
	p_Stream << "}";

	p_Stream << "}";
}

void SCppEntitySubsetInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("name") << ":";
	p_Stream << simdjson::as_json_string(s_Object->name);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	TypeID::WriteSimpleJson(&s_Object->type, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("flags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->flags);

	p_Stream << "}";
}

void SCppEntitySubsetInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntitySubsetInfo s_Object {};

	s_Object.name = std::string_view(p_Document["name"]);

	{
		TypeID s_Item {};
		TypeID::FromSimpleJson(p_Document["type"], &s_Item);
		s_Object.type = s_Item;
	}

	s_Object.flags = simdjson::from_json_uint32(p_Document["flags"]);

	*reinterpret_cast<SCppEntitySubsetInfo*>(p_Target) = s_Object;
}

void SCppEntitySubsetInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	ZString::Serialize(&s_Object->name, p_Serializer, p_OwnOffset + offsetof(SCppEntitySubsetInfo, name));
	TypeID::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(SCppEntitySubsetInfo, type));
}

bool SCppEntitySubsetInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntitySubsetInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntitySubsetInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntitySubsetInfo::operator==(const SCppEntitySubsetInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntitySubsetInfo>)
		return false;

	if (name != p_Other.name) return false;
	if (type != p_Other.type) return false;
	if (flags != p_Other.flags) return false;

	return true;
}

ZHMTypeInfo SCppEntityBlueprint::TypeInfo = ZHMTypeInfo("SCppEntityBlueprint", sizeof(SCppEntityBlueprint), alignof(SCppEntityBlueprint), SCppEntityBlueprint::WriteJson, SCppEntityBlueprint::WriteSimpleJson, SCppEntityBlueprint::FromSimpleJson, SCppEntityBlueprint::Serialize, SCppEntityBlueprint::Equals);

void SCppEntityBlueprint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("typeName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TypeID") << ",\"$val\":";
	TypeID::WriteJson(&s_Object->typeName, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subsets") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCppEntitySubsetInfo>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->subsets[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCppEntitySubsetInfo") << ",\"$val\":";
		SCppEntitySubsetInfo::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->subsets.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCppEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("typeName") << ":";
	TypeID::WriteSimpleJson(&s_Object->typeName, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subsets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->subsets[i];
		SCppEntitySubsetInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->subsets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCppEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntityBlueprint s_Object {};

	{
		TypeID s_Item {};
		TypeID::FromSimpleJson(p_Document["typeName"], &s_Item);
		s_Object.typeName = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["subsets"];
	s_Object.subsets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCppEntitySubsetInfo s_ArrayItem0;
		SCppEntitySubsetInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.subsets[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCppEntityBlueprint*>(p_Target) = s_Object;
}

void SCppEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	TypeID::Serialize(&s_Object->typeName, p_Serializer, p_OwnOffset + offsetof(SCppEntityBlueprint, typeName));
	TArray<SCppEntitySubsetInfo>::Serialize(&s_Object->subsets, p_Serializer, p_OwnOffset + offsetof(SCppEntityBlueprint, subsets));
}

bool SCppEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntityBlueprint::operator==(const SCppEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntityBlueprint>)
		return false;

	if (typeName != p_Other.typeName) return false;
	if (subsets != p_Other.subsets) return false;

	return true;
}

ZHMTypeInfo SCppEntityTemplate::TypeInfo = ZHMTypeInfo("SCppEntityTemplate", sizeof(SCppEntityTemplate), alignof(SCppEntityTemplate), SCppEntityTemplate::WriteJson, SCppEntityTemplate::WriteSimpleJson, SCppEntityTemplate::FromSimpleJson, SCppEntityTemplate::Serialize, SCppEntityTemplate::Equals);

void SCppEntityTemplate::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntityTemplate*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("moduleName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->moduleName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("typeName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TypeID") << ",\"$val\":";
	TypeID::WriteJson(&s_Object->typeName, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplateProperty>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateProperty") << ",\"$val\":";
		SEntityTemplateProperty::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subsets") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCppEntitySubsetInfo>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->subsets[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCppEntitySubsetInfo") << ",\"$val\":";
		SCppEntitySubsetInfo::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->subsets.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCppEntityTemplate::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntityTemplate*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("moduleName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->moduleName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("typeName") << ":";
	TypeID::WriteSimpleJson(&s_Object->typeName, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subsets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->subsets[i];
		SCppEntitySubsetInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->subsets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCppEntityTemplate::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntityTemplate s_Object {};

	s_Object.moduleName = std::string_view(p_Document["moduleName"]);

	{
		TypeID s_Item {};
		TypeID::FromSimpleJson(p_Document["typeName"], &s_Item);
		s_Object.typeName = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyValues"];
	s_Object.propertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyValues[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["subsets"];
	s_Object.subsets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCppEntitySubsetInfo s_ArrayItem0;
		SCppEntitySubsetInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.subsets[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCppEntityTemplate*>(p_Target) = s_Object;
}

void SCppEntityTemplate::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntityTemplate*>(p_Object);

	ZString::Serialize(&s_Object->moduleName, p_Serializer, p_OwnOffset + offsetof(SCppEntityTemplate, moduleName));
	TypeID::Serialize(&s_Object->typeName, p_Serializer, p_OwnOffset + offsetof(SCppEntityTemplate, typeName));
	TArray<SEntityTemplateProperty>::Serialize(&s_Object->propertyValues, p_Serializer, p_OwnOffset + offsetof(SCppEntityTemplate, propertyValues));
	TArray<SCppEntitySubsetInfo>::Serialize(&s_Object->subsets, p_Serializer, p_OwnOffset + offsetof(SCppEntityTemplate, subsets));
}

bool SCppEntityTemplate::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntityTemplate*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntityTemplate*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntityTemplate::operator==(const SCppEntityTemplate& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntityTemplate>)
		return false;

	if (moduleName != p_Other.moduleName) return false;
	if (typeName != p_Other.typeName) return false;
	if (propertyValues != p_Other.propertyValues) return false;
	if (subsets != p_Other.subsets) return false;

	return true;
}

ZHMTypeInfo SCrowdCells::TypeInfo = ZHMTypeInfo("SCrowdCells", sizeof(SCrowdCells), alignof(SCrowdCells), SCrowdCells::WriteJson, SCrowdCells::WriteSimpleJson, SCrowdCells::FromSimpleJson, SCrowdCells::Serialize, SCrowdCells::Equals);

void SCrowdCells::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_cells") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TFixedArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cells.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cells[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_cells.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdCells::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_cells") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cells.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cells[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_cells.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdCells::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdCells s_Object {};

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_cells"])
	{
		s_Object.m_cells[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

	*reinterpret_cast<SCrowdCells*>(p_Target) = s_Object;
}

void SCrowdCells::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	TFixedArray<uint8, 128>::Serialize(&s_Object->m_cells, p_Serializer, p_OwnOffset + offsetof(SCrowdCells, m_cells));
}

bool SCrowdCells::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdCells*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdCells*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdCells::operator==(const SCrowdCells& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdCells>)
		return false;

	if (m_cells != p_Other.m_cells) return false;

	return true;
}

ZHMTypeInfo SCrowdFlowChannel::TypeInfo = ZHMTypeInfo("SCrowdFlowChannel", sizeof(SCrowdFlowChannel), alignof(SCrowdFlowChannel), SCrowdFlowChannel::WriteJson, SCrowdFlowChannel::WriteSimpleJson, SCrowdFlowChannel::FromSimpleJson, SCrowdFlowChannel::Serialize, SCrowdFlowChannel::Equals);

void SCrowdFlowChannel::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aFlowVectorIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowVectorIndex.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowVectorIndex[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aFlowVectorIndex.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowCost") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowCost.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowCost[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aFlowCost.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdFlowChannel::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aFlowVectorIndex") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowVectorIndex.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowVectorIndex[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFlowVectorIndex.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowCost") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowCost.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowCost[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFlowCost.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdFlowChannel::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdFlowChannel s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFlowVectorIndex"];
	s_Object.m_aFlowVectorIndex.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aFlowVectorIndex[s_Index0++] = simdjson::from_json_uint8(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFlowCost"];
	s_Object.m_aFlowCost.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aFlowCost[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	*reinterpret_cast<SCrowdFlowChannel*>(p_Target) = s_Object;
}

void SCrowdFlowChannel::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	TArray<uint8>::Serialize(&s_Object->m_aFlowVectorIndex, p_Serializer, p_OwnOffset + offsetof(SCrowdFlowChannel, m_aFlowVectorIndex));
	TArray<uint16>::Serialize(&s_Object->m_aFlowCost, p_Serializer, p_OwnOffset + offsetof(SCrowdFlowChannel, m_aFlowCost));
}

bool SCrowdFlowChannel::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdFlowChannel*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdFlowChannel*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdFlowChannel::operator==(const SCrowdFlowChannel& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdFlowChannel>)
		return false;

	if (m_aFlowVectorIndex != p_Other.m_aFlowVectorIndex) return false;
	if (m_aFlowCost != p_Other.m_aFlowCost) return false;

	return true;
}

ZHMTypeInfo SMatrix::TypeInfo = ZHMTypeInfo("SMatrix", sizeof(SMatrix), alignof(SMatrix), SMatrix::WriteJson, SMatrix::WriteSimpleJson, SMatrix::FromSimpleJson, SMatrix::Serialize, SMatrix::Equals);

void SMatrix::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("XAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->XAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->YAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->ZAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->Trans, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SMatrix::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	float4::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	float4::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	float4::WriteSimpleJson(&s_Object->ZAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	float4::WriteSimpleJson(&s_Object->Trans, p_Stream);

	p_Stream << "}";
}

void SMatrix::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["XAxis"], &s_Item);
		s_Object.XAxis = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["YAxis"], &s_Item);
		s_Object.YAxis = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["ZAxis"], &s_Item);
		s_Object.ZAxis = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["Trans"], &s_Item);
		s_Object.Trans = s_Item;
	}

	*reinterpret_cast<SMatrix*>(p_Target) = s_Object;
}

void SMatrix::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	float4::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, XAxis));
	float4::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, YAxis));
	float4::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, ZAxis));
	float4::Serialize(&s_Object->Trans, p_Serializer, p_OwnOffset + offsetof(SMatrix, Trans));
}

bool SMatrix::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix::operator==(const SMatrix& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;
	if (Trans != p_Other.Trans) return false;

	return true;
}

ZHMTypeInfo SVector4::TypeInfo = ZHMTypeInfo("SVector4", sizeof(SVector4), alignof(SVector4), SVector4::WriteJson, SVector4::WriteSimpleJson, SVector4::FromSimpleJson, SVector4::Serialize, SVector4::Equals);

void SVector4::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->w);
	p_Stream << "}";

	p_Stream << "}";
}

void SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << simdjson::as_json_string(s_Object->w);

	p_Stream << "}";
}

void SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVector4 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	s_Object.z = simdjson::from_json_float32(p_Document["z"]);

	s_Object.w = simdjson::from_json_float32(p_Document["w"]);

	*reinterpret_cast<SVector4*>(p_Target) = s_Object;
}

void SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

}

bool SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector4::operator==(const SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector4>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;
	if (w != p_Other.w) return false;

	return true;
}

ZHMTypeInfo ZCrowdGridPoint::TypeInfo = ZHMTypeInfo("ZCrowdGridPoint", sizeof(ZCrowdGridPoint), alignof(ZCrowdGridPoint), ZCrowdGridPoint::WriteJson, ZCrowdGridPoint::WriteSimpleJson, ZCrowdGridPoint::FromSimpleJson, ZCrowdGridPoint::Serialize, ZCrowdGridPoint::Equals);

void ZCrowdGridPoint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nHeightOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHeightOffset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOnNavGrid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOnNavGrid);
	p_Stream << "}";

	p_Stream << "}";
}

void ZCrowdGridPoint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nHeightOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHeightOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOnNavGrid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOnNavGrid);

	p_Stream << "}";
}

void ZCrowdGridPoint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZCrowdGridPoint s_Object {};

	s_Object.m_nHeightOffset = simdjson::from_json_int16(p_Document["m_nHeightOffset"]);

	s_Object.m_nOnNavGrid = simdjson::from_json_uint8(p_Document["m_nOnNavGrid"]);

	*reinterpret_cast<ZCrowdGridPoint*>(p_Target) = s_Object;
}

void ZCrowdGridPoint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

}

bool ZCrowdGridPoint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCrowdGridPoint*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCrowdGridPoint*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCrowdGridPoint::operator==(const ZCrowdGridPoint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCrowdGridPoint>)
		return false;

	if (m_nHeightOffset != p_Other.m_nHeightOffset) return false;
	if (m_nOnNavGrid != p_Other.m_nOnNavGrid) return false;

	return true;
}

ZHMTypeInfo SCrowdMapData::TypeInfo = ZHMTypeInfo("SCrowdMapData", sizeof(SCrowdMapData), alignof(SCrowdMapData), SCrowdMapData::WriteJson, SCrowdMapData::WriteSimpleJson, SCrowdMapData::FromSimpleJson, SCrowdMapData::Serialize, SCrowdMapData::Equals);

void SCrowdMapData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCellConsts") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vCellConsts, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeX") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeX);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeY") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeY);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeX") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeX);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeY") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeY);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GridMap") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZCrowdGridPoint>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_GridMap.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_GridMap[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZCrowdGridPoint") << ",\"$val\":";
		ZCrowdGridPoint::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_GridMap.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsScale") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsScale);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsBias") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsBias);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellFlags") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdCells>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellFlags.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellFlags[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdCells") << ",\"$val\":";
		SCrowdCells::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_CellFlags.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowChannels") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdFlowChannel>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowChannels.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowChannels[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdFlowChannel") << ",\"$val\":";
		SCrowdFlowChannel::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aFlowChannels.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCellSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCellSize);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mObjectToWorld") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMatrix") << ",\"$val\":";
	SMatrix::WriteJson(&s_Object->m_mObjectToWorld, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vGlobalSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vGlobalSize, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridGeneratorOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridGeneratorOffset);
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdMapData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCellConsts") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vCellConsts, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GridMap") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_GridMap.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_GridMap[i];
		ZCrowdGridPoint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_GridMap.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsBias") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsBias);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellFlags") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellFlags.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellFlags[i];
		SCrowdCells::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CellFlags.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowChannels") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowChannels.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowChannels[i];
		SCrowdFlowChannel::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aFlowChannels.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCellSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCellSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mObjectToWorld") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_mObjectToWorld, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vGlobalSize") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vGlobalSize, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridGeneratorOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridGeneratorOffset);

	p_Stream << "}";
}

void SCrowdMapData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdMapData s_Object {};

	s_Object.m_nVersion = simdjson::from_json_uint32(p_Document["m_nVersion"]);

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vCellConsts"], &s_Item);
		s_Object.m_vCellConsts = s_Item;
	}

	s_Object.m_nGridSizeX = simdjson::from_json_uint32(p_Document["m_nGridSizeX"]);

	s_Object.m_nGridSizeY = simdjson::from_json_uint32(p_Document["m_nGridSizeY"]);

	s_Object.m_nCellSizeX = simdjson::from_json_uint32(p_Document["m_nCellSizeX"]);

	s_Object.m_nCellSizeY = simdjson::from_json_uint32(p_Document["m_nCellSizeY"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_GridMap"];
	s_Object.m_GridMap.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZCrowdGridPoint s_ArrayItem0;
		ZCrowdGridPoint::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_GridMap[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_fGridMapHeightOffsetsScale = simdjson::from_json_float32(p_Document["m_fGridMapHeightOffsetsScale"]);

	s_Object.m_fGridMapHeightOffsetsBias = simdjson::from_json_float32(p_Document["m_fGridMapHeightOffsetsBias"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CellFlags"];
	s_Object.m_CellFlags.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdCells s_ArrayItem0;
		SCrowdCells::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_CellFlags[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFlowChannels"];
	s_Object.m_aFlowChannels.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdFlowChannel s_ArrayItem0;
		SCrowdFlowChannel::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aFlowChannels[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_nGridCellSize = simdjson::from_json_float32(p_Document["m_nGridCellSize"]);

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_mObjectToWorld"], &s_Item);
		s_Object.m_mObjectToWorld = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vGlobalSize"], &s_Item);
		s_Object.m_vGlobalSize = s_Item;
	}

	s_Object.m_nGridGeneratorOffset = simdjson::from_json_float32(p_Document["m_nGridGeneratorOffset"]);

	*reinterpret_cast<SCrowdMapData*>(p_Target) = s_Object;
}

void SCrowdMapData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	SVector4::Serialize(&s_Object->m_vCellConsts, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_vCellConsts));
	TArray<ZCrowdGridPoint>::Serialize(&s_Object->m_GridMap, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_GridMap));
	TArray<SCrowdCells>::Serialize(&s_Object->m_CellFlags, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_CellFlags));
	TArray<SCrowdFlowChannel>::Serialize(&s_Object->m_aFlowChannels, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_aFlowChannels));
	SMatrix::Serialize(&s_Object->m_mObjectToWorld, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_mObjectToWorld));
	SVector3::Serialize(&s_Object->m_vGlobalSize, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_vGlobalSize));
}

bool SCrowdMapData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdMapData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdMapData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdMapData::operator==(const SCrowdMapData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdMapData>)
		return false;

	if (m_nVersion != p_Other.m_nVersion) return false;
	if (m_vCellConsts != p_Other.m_vCellConsts) return false;
	if (m_nGridSizeX != p_Other.m_nGridSizeX) return false;
	if (m_nGridSizeY != p_Other.m_nGridSizeY) return false;
	if (m_nCellSizeX != p_Other.m_nCellSizeX) return false;
	if (m_nCellSizeY != p_Other.m_nCellSizeY) return false;
	if (m_GridMap != p_Other.m_GridMap) return false;
	if (m_fGridMapHeightOffsetsScale != p_Other.m_fGridMapHeightOffsetsScale) return false;
	if (m_fGridMapHeightOffsetsBias != p_Other.m_fGridMapHeightOffsetsBias) return false;
	if (m_CellFlags != p_Other.m_CellFlags) return false;
	if (m_aFlowChannels != p_Other.m_aFlowChannels) return false;
	if (m_nGridCellSize != p_Other.m_nGridCellSize) return false;
	if (m_mObjectToWorld != p_Other.m_mObjectToWorld) return false;
	if (m_vGlobalSize != p_Other.m_vGlobalSize) return false;
	if (m_nGridGeneratorOffset != p_Other.m_nGridGeneratorOffset) return false;

	return true;
}

ZHMTypeInfo SDLCItemSaveData::TypeInfo = ZHMTypeInfo("SDLCItemSaveData", sizeof(SDLCItemSaveData), alignof(SDLCItemSaveData), SDLCItemSaveData::WriteJson, SDLCItemSaveData::WriteSimpleJson, SDLCItemSaveData::FromSimpleJson, SDLCItemSaveData::Serialize, SDLCItemSaveData::Equals);

void SDLCItemSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDLCItemSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SDLCItemSaveData.EDiscoverState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SDLCItemSaveData.EDiscoverState", static_cast<int>(s_Object->m_eState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TokenID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STokenID") << ",\"$val\":";
	STokenID::WriteJson(&s_Object->m_TokenID, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SDLCItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDLCItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SDLCItemSaveData.EDiscoverState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TokenID") << ":";
	STokenID::WriteSimpleJson(&s_Object->m_TokenID, p_Stream);

	p_Stream << "}";
}

void SDLCItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDLCItemSaveData s_Object {};

	s_Object.m_eState = static_cast<SDLCItemSaveData_EDiscoverState>(ZHMEnums::GetEnumValueByName("SDLCItemSaveData.EDiscoverState", std::string_view(p_Document["m_eState"])));

	{
		STokenID s_Item {};
		STokenID::FromSimpleJson(p_Document["m_TokenID"], &s_Item);
		s_Object.m_TokenID = s_Item;
	}

	*reinterpret_cast<SDLCItemSaveData*>(p_Target) = s_Object;
}

void SDLCItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDLCItemSaveData*>(p_Object);

	STokenID::Serialize(&s_Object->m_TokenID, p_Serializer, p_OwnOffset + offsetof(SDLCItemSaveData, m_TokenID));
}

bool SDLCItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDLCItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDLCItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDLCItemSaveData::operator==(const SDLCItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDLCItemSaveData>)
		return false;

	if (m_eState != p_Other.m_eState) return false;
	if (m_TokenID != p_Other.m_TokenID) return false;

	return true;
}

ZHMTypeInfo SDoorSoundDefs::TypeInfo = ZHMTypeInfo("SDoorSoundDefs", sizeof(SDoorSoundDefs), alignof(SDoorSoundDefs), SDoorSoundDefs::WriteJson, SDoorSoundDefs::WriteSimpleJson, SDoorSoundDefs::FromSimpleJson, SDoorSoundDefs::Serialize, SDoorSoundDefs::Equals);

void SDoorSoundDefs::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SDoorSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SDoorSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDoorSoundDefs s_Object {};

	*reinterpret_cast<SDoorSoundDefs*>(p_Target) = s_Object;
}

void SDoorSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

}

bool SDoorSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorSoundDefs::operator==(const SDoorSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorSoundDefs>)
		return false;


	return true;
}

ZHMTypeInfo SEntityPinDescriptor::TypeInfo = ZHMTypeInfo("SEntityPinDescriptor", sizeof(SEntityPinDescriptor), alignof(SEntityPinDescriptor), SEntityPinDescriptor::WriteJson, SEntityPinDescriptor::WriteSimpleJson, SEntityPinDescriptor::FromSimpleJson, SEntityPinDescriptor::Serialize, SEntityPinDescriptor::Equals);

void SEntityPinDescriptor::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZResourceID") << ",\"$val\":";
	ZResourceID::WriteJson(&s_Object->type, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsPlaceholder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bIsPlaceholder);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityPinDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->type, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsPlaceholder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsPlaceholder);

	p_Stream << "}";
}

void SEntityPinDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityPinDescriptor s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	s_Object.sDisplayName = std::string_view(p_Document["sDisplayName"]);

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["type"], &s_Item);
		s_Object.type = s_Item;
	}

	s_Object.sHelpText = std::string_view(p_Document["sHelpText"]);

	s_Object.bIsPlaceholder = simdjson::from_json_bool(p_Document["bIsPlaceholder"]);

	*reinterpret_cast<SEntityPinDescriptor*>(p_Target) = s_Object;
}

void SEntityPinDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sName));
	ZString::Serialize(&s_Object->sDisplayName, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sDisplayName));
	ZResourceID::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, type));
	ZString::Serialize(&s_Object->sHelpText, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sHelpText));
}

bool SEntityPinDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityPinDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityPinDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityPinDescriptor::operator==(const SEntityPinDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityPinDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (sDisplayName != p_Other.sDisplayName) return false;
	if (type != p_Other.type) return false;
	if (sHelpText != p_Other.sHelpText) return false;
	if (bIsPlaceholder != p_Other.bIsPlaceholder) return false;

	return true;
}

ZHMTypeInfo SEntityTemplateEntitySubset::TypeInfo = ZHMTypeInfo("SEntityTemplateEntitySubset", sizeof(SEntityTemplateEntitySubset), alignof(SEntityTemplateEntitySubset), SEntityTemplateEntitySubset::WriteJson, SEntityTemplateEntitySubset::WriteSimpleJson, SEntityTemplateEntitySubset::FromSimpleJson, SEntityTemplateEntitySubset::Serialize, SEntityTemplateEntitySubset::Equals);

void SEntityTemplateEntitySubset::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("subsetType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TypeID") << ",\"$val\":";
	TypeID::WriteJson(&s_Object->subsetType, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entities.size(); ++i)
	{
		auto& s_Item0 = s_Object->entities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->entities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplateEntitySubset::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("subsetType") << ":";
	TypeID::WriteSimpleJson(&s_Object->subsetType, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entities.size(); ++i)
	{
		auto& s_Item0 = s_Object->entities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->entities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEntityTemplateEntitySubset::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateEntitySubset s_Object {};

	{
		TypeID s_Item {};
		TypeID::FromSimpleJson(p_Document["subsetType"], &s_Item);
		s_Object.subsetType = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["entities"];
	s_Object.entities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.entities[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	*reinterpret_cast<SEntityTemplateEntitySubset*>(p_Target) = s_Object;
}

void SEntityTemplateEntitySubset::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	TypeID::Serialize(&s_Object->subsetType, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateEntitySubset, subsetType));
	TArray<int32>::Serialize(&s_Object->entities, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateEntitySubset, entities));
}

bool SEntityTemplateEntitySubset::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateEntitySubset::operator==(const SEntityTemplateEntitySubset& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateEntitySubset>)
		return false;

	if (subsetType != p_Other.subsetType) return false;
	if (entities != p_Other.entities) return false;

	return true;
}

ZHMTypeInfo SEntityTemplatePinConnection::TypeInfo = ZHMTypeInfo("SEntityTemplatePinConnection", sizeof(SEntityTemplatePinConnection), alignof(SEntityTemplatePinConnection), SEntityTemplatePinConnection::WriteJson, SEntityTemplatePinConnection::WriteSimpleJson, SEntityTemplatePinConnection::FromSimpleJson, SEntityTemplatePinConnection::Serialize, SEntityTemplatePinConnection::Equals);

void SEntityTemplatePinConnection::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("fromID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fromID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->toID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fromPinName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fromPinName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toPinName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->toPinName);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplatePinConnection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fromID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fromID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->toID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fromPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fromPinName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->toPinName);

	p_Stream << "}";
}

void SEntityTemplatePinConnection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplatePinConnection s_Object {};

	s_Object.fromID = simdjson::from_json_int32(p_Document["fromID"]);

	s_Object.toID = simdjson::from_json_int32(p_Document["toID"]);

	s_Object.fromPinName = std::string_view(p_Document["fromPinName"]);

	s_Object.toPinName = std::string_view(p_Document["toPinName"]);

	*reinterpret_cast<SEntityTemplatePinConnection*>(p_Target) = s_Object;
}

void SEntityTemplatePinConnection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	ZString::Serialize(&s_Object->fromPinName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePinConnection, fromPinName));
	ZString::Serialize(&s_Object->toPinName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePinConnection, toPinName));
}

bool SEntityTemplatePinConnection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePinConnection*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePinConnection*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePinConnection::operator==(const SEntityTemplatePinConnection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePinConnection>)
		return false;

	if (fromID != p_Other.fromID) return false;
	if (toID != p_Other.toID) return false;
	if (fromPinName != p_Other.fromPinName) return false;
	if (toPinName != p_Other.toPinName) return false;

	return true;
}

ZHMTypeInfo SEntityTemplatePropertyAlias::TypeInfo = ZHMTypeInfo("SEntityTemplatePropertyAlias", sizeof(SEntityTemplatePropertyAlias), alignof(SEntityTemplatePropertyAlias), SEntityTemplatePropertyAlias::WriteJson, SEntityTemplatePropertyAlias::WriteSimpleJson, SEntityTemplatePropertyAlias::FromSimpleJson, SEntityTemplatePropertyAlias::Serialize, SEntityTemplatePropertyAlias::Equals);

void SEntityTemplatePropertyAlias::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sAliasName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sAliasName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sPropertyName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sPropertyName);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplatePropertyAlias::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sAliasName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sAliasName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sPropertyName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sPropertyName);

	p_Stream << "}";
}

void SEntityTemplatePropertyAlias::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplatePropertyAlias s_Object {};

	s_Object.sAliasName = std::string_view(p_Document["sAliasName"]);

	s_Object.entityID = simdjson::from_json_int32(p_Document["entityID"]);

	s_Object.sPropertyName = std::string_view(p_Document["sPropertyName"]);

	*reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Target) = s_Object;
}

void SEntityTemplatePropertyAlias::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	ZString::Serialize(&s_Object->sAliasName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyAlias, sAliasName));
	ZString::Serialize(&s_Object->sPropertyName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyAlias, sPropertyName));
}

bool SEntityTemplatePropertyAlias::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePropertyAlias::operator==(const SEntityTemplatePropertyAlias& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePropertyAlias>)
		return false;

	if (sAliasName != p_Other.sAliasName) return false;
	if (entityID != p_Other.entityID) return false;
	if (sPropertyName != p_Other.sPropertyName) return false;

	return true;
}

ZHMTypeInfo SEntityTemplateReference::TypeInfo = ZHMTypeInfo("SEntityTemplateReference", sizeof(SEntityTemplateReference), alignof(SEntityTemplateReference), SEntityTemplateReference::WriteJson, SEntityTemplateReference::WriteSimpleJson, SEntityTemplateReference::FromSimpleJson, SEntityTemplateReference::Serialize, SEntityTemplateReference::Equals);

void SEntityTemplateReference::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("entityIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->exposedEntity);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplateReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("entityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->exposedEntity);

	p_Stream << "}";
}

void SEntityTemplateReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateReference s_Object {};

	s_Object.entityIndex = simdjson::from_json_int32(p_Document["entityIndex"]);

	s_Object.exposedEntity = std::string_view(p_Document["exposedEntity"]);

	*reinterpret_cast<SEntityTemplateReference*>(p_Target) = s_Object;
}

void SEntityTemplateReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	ZString::Serialize(&s_Object->exposedEntity, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateReference, exposedEntity));
}

bool SEntityTemplateReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateReference*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateReference::operator==(const SEntityTemplateReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateReference>)
		return false;

	if (entityIndex != p_Other.entityIndex) return false;
	if (exposedEntity != p_Other.exposedEntity) return false;

	return true;
}

ZHMTypeInfo SExposedEntityDescriptor::TypeInfo = ZHMTypeInfo("SExposedEntityDescriptor", sizeof(SExposedEntityDescriptor), alignof(SExposedEntityDescriptor), SExposedEntityDescriptor::WriteJson, SExposedEntityDescriptor::WriteSimpleJson, SExposedEntityDescriptor::FromSimpleJson, SExposedEntityDescriptor::Serialize, SExposedEntityDescriptor::Equals);

void SExposedEntityDescriptor::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sUpheldContract") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sUpheldContract);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << "}";

	p_Stream << "}";
}

void SExposedEntityDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sUpheldContract") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sUpheldContract);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);

	p_Stream << "}";
}

void SExposedEntityDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExposedEntityDescriptor s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	s_Object.sDisplayName = std::string_view(p_Document["sDisplayName"]);

	s_Object.sUpheldContract = std::string_view(p_Document["sUpheldContract"]);

	s_Object.sHelpText = std::string_view(p_Document["sHelpText"]);

	*reinterpret_cast<SExposedEntityDescriptor*>(p_Target) = s_Object;
}

void SExposedEntityDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sName));
	ZString::Serialize(&s_Object->sDisplayName, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sDisplayName));
	ZString::Serialize(&s_Object->sUpheldContract, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sUpheldContract));
	ZString::Serialize(&s_Object->sHelpText, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sHelpText));
}

bool SExposedEntityDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExposedEntityDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SExposedEntityDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExposedEntityDescriptor::operator==(const SExposedEntityDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExposedEntityDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (sDisplayName != p_Other.sDisplayName) return false;
	if (sUpheldContract != p_Other.sUpheldContract) return false;
	if (sHelpText != p_Other.sHelpText) return false;

	return true;
}

ZHMTypeInfo SFRange::TypeInfo = ZHMTypeInfo("SFRange", sizeof(SFRange), alignof(SFRange), SFRange::WriteJson, SFRange::WriteSimpleJson, SFRange::FromSimpleJson, SFRange::Serialize, SFRange::Equals);

void SFRange::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFRange*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fMin") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMin);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMax);
	p_Stream << "}";

	p_Stream << "}";
}

void SFRange::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFRange*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fMin") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMin);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMax);

	p_Stream << "}";
}

void SFRange::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFRange s_Object {};

	s_Object.m_fMin = simdjson::from_json_float32(p_Document["m_fMin"]);

	s_Object.m_fMax = simdjson::from_json_float32(p_Document["m_fMax"]);

	*reinterpret_cast<SFRange*>(p_Target) = s_Object;
}

void SFRange::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFRange*>(p_Object);

}

bool SFRange::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFRange*>(p_Left);
	auto* s_Right = reinterpret_cast<SFRange*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFRange::operator==(const SFRange& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFRange>)
		return false;

	if (m_fMin != p_Other.m_fMin) return false;
	if (m_fMax != p_Other.m_fMax) return false;

	return true;
}

ZHMTypeInfo SForwardSpawnData::TypeInfo = ZHMTypeInfo("SForwardSpawnData", sizeof(SForwardSpawnData), alignof(SForwardSpawnData), SForwardSpawnData::WriteJson, SForwardSpawnData::WriteSimpleJson, SForwardSpawnData::FromSimpleJson, SForwardSpawnData::Serialize, SForwardSpawnData::Equals);

void SForwardSpawnData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SForwardSpawnData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iForwardSpawnIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iForwardSpawnIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SCheckpointSaveData") << ",\"$val\":";
	SCheckpointSaveData::WriteJson(&s_Object->m_SaveData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SForwardSpawnData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SForwardSpawnData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iForwardSpawnIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iForwardSpawnIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SaveData") << ":";
	SCheckpointSaveData::WriteSimpleJson(&s_Object->m_SaveData, p_Stream);

	p_Stream << "}";
}

void SForwardSpawnData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SForwardSpawnData s_Object {};

	s_Object.m_iForwardSpawnIndex = simdjson::from_json_int32(p_Document["m_iForwardSpawnIndex"]);

	{
		SCheckpointSaveData s_Item {};
		SCheckpointSaveData::FromSimpleJson(p_Document["m_SaveData"], &s_Item);
		s_Object.m_SaveData = s_Item;
	}

	*reinterpret_cast<SForwardSpawnData*>(p_Target) = s_Object;
}

void SForwardSpawnData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SForwardSpawnData*>(p_Object);

	SCheckpointSaveData::Serialize(&s_Object->m_SaveData, p_Serializer, p_OwnOffset + offsetof(SForwardSpawnData, m_SaveData));
}

bool SForwardSpawnData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SForwardSpawnData*>(p_Left);
	auto* s_Right = reinterpret_cast<SForwardSpawnData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SForwardSpawnData::operator==(const SForwardSpawnData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SForwardSpawnData>)
		return false;

	if (m_iForwardSpawnIndex != p_Other.m_iForwardSpawnIndex) return false;
	if (m_SaveData != p_Other.m_SaveData) return false;

	return true;
}

ZHMTypeInfo SGProperties::TypeInfo = ZHMTypeInfo("SGProperties", sizeof(SGProperties), alignof(SGProperties), SGProperties::WriteJson, SGProperties::WriteSimpleJson, SGProperties::FromSimpleJson, SGProperties::Serialize, SGProperties::Equals);

void SGProperties::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("vMin") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->vMin, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->vMax, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nGridWidth") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nGridWidth);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fGridSpacing") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fGridSpacing);
	p_Stream << "}";

	p_Stream << "}";
}

void SGProperties::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("vMin") << ":";
	float4::WriteSimpleJson(&s_Object->vMin, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vMax") << ":";
	float4::WriteSimpleJson(&s_Object->vMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nGridWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nGridWidth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fGridSpacing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fGridSpacing);

	p_Stream << "}";
}

void SGProperties::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGProperties s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["vMin"], &s_Item);
		s_Object.vMin = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["vMax"], &s_Item);
		s_Object.vMax = s_Item;
	}

	s_Object.nGridWidth = simdjson::from_json_int32(p_Document["nGridWidth"]);

	s_Object.fGridSpacing = simdjson::from_json_float32(p_Document["fGridSpacing"]);

	*reinterpret_cast<SGProperties*>(p_Target) = s_Object;
}

void SGProperties::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	float4::Serialize(&s_Object->vMin, p_Serializer, p_OwnOffset + offsetof(SGProperties, vMin));
	float4::Serialize(&s_Object->vMax, p_Serializer, p_OwnOffset + offsetof(SGProperties, vMax));
}

bool SGProperties::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGProperties*>(p_Left);
	auto* s_Right = reinterpret_cast<SGProperties*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGProperties::operator==(const SGProperties& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGProperties>)
		return false;

	if (vMin != p_Other.vMin) return false;
	if (vMax != p_Other.vMax) return false;
	if (nGridWidth != p_Other.nGridWidth) return false;
	if (fGridSpacing != p_Other.fGridSpacing) return false;

	return true;
}

ZHMTypeInfo SGWaypoint::TypeInfo = ZHMTypeInfo("SGWaypoint", sizeof(SGWaypoint), alignof(SGWaypoint), SGWaypoint::WriteJson, SGWaypoint::WriteSimpleJson, SGWaypoint::FromSimpleJson, SGWaypoint::Serialize, SGWaypoint::Equals);

void SGWaypoint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("nNeighbor0") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor0);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor1") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor1);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor2") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor2);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor3") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor3);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor4") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor4);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor5") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor5);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor6") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor6);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor7") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor7);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vPos") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->vPos, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SGWaypoint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nNeighbor0") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor0);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor1") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor1);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor2") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor2);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor3") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor3);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor4") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor4);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor5") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor5);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor6") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor6);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor7") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor7);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vPos") << ":";
	float4::WriteSimpleJson(&s_Object->vPos, p_Stream);

	p_Stream << "}";
}

void SGWaypoint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGWaypoint s_Object {};

	s_Object.nNeighbor0 = simdjson::from_json_int16(p_Document["nNeighbor0"]);

	s_Object.nNeighbor1 = simdjson::from_json_int16(p_Document["nNeighbor1"]);

	s_Object.nNeighbor2 = simdjson::from_json_int16(p_Document["nNeighbor2"]);

	s_Object.nNeighbor3 = simdjson::from_json_int16(p_Document["nNeighbor3"]);

	s_Object.nNeighbor4 = simdjson::from_json_int16(p_Document["nNeighbor4"]);

	s_Object.nNeighbor5 = simdjson::from_json_int16(p_Document["nNeighbor5"]);

	s_Object.nNeighbor6 = simdjson::from_json_int16(p_Document["nNeighbor6"]);

	s_Object.nNeighbor7 = simdjson::from_json_int16(p_Document["nNeighbor7"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["vPos"], &s_Item);
		s_Object.vPos = s_Item;
	}

	*reinterpret_cast<SGWaypoint*>(p_Target) = s_Object;
}

void SGWaypoint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	float4::Serialize(&s_Object->vPos, p_Serializer, p_OwnOffset + offsetof(SGWaypoint, vPos));
}

bool SGWaypoint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGWaypoint*>(p_Left);
	auto* s_Right = reinterpret_cast<SGWaypoint*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGWaypoint::operator==(const SGWaypoint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGWaypoint>)
		return false;

	if (nNeighbor0 != p_Other.nNeighbor0) return false;
	if (nNeighbor1 != p_Other.nNeighbor1) return false;
	if (nNeighbor2 != p_Other.nNeighbor2) return false;
	if (nNeighbor3 != p_Other.nNeighbor3) return false;
	if (nNeighbor4 != p_Other.nNeighbor4) return false;
	if (nNeighbor5 != p_Other.nNeighbor5) return false;
	if (nNeighbor6 != p_Other.nNeighbor6) return false;
	if (nNeighbor7 != p_Other.nNeighbor7) return false;
	if (vPos != p_Other.vPos) return false;

	return true;
}

ZHMTypeInfo SGameStats::TypeInfo = ZHMTypeInfo("SGameStats", sizeof(SGameStats), alignof(SGameStats), SGameStats::WriteJson, SGameStats::WriteSimpleJson, SGameStats::FromSimpleJson, SGameStats::Serialize, SGameStats::Equals);

void SGameStats::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStats*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aKillsByBodyPart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKillsByBodyPart.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKillsByBodyPart[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aKillsByBodyPart.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKillsByWeapon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKillsByWeapon.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKillsByWeapon[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aKillsByWeapon.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKillsBySituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKillsBySituation.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKillsBySituation[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aKillsBySituation.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKillsByVictim") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKillsByVictim.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKillsByVictim[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aKillsByVictim.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorDamageByBodyPart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorDamageByBodyPart.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorDamageByBodyPart[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aActorDamageByBodyPart.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorDamageByWeapon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorDamageByWeapon.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorDamageByWeapon[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aActorDamageByWeapon.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStealthSituations") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStealthSituations.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStealthSituations[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aStealthSituations.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aExplodingProps") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aExplodingProps.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aExplodingProps[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aExplodingProps.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SGameStats::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStats*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKillsByBodyPart") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKillsByBodyPart.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKillsByBodyPart[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKillsByBodyPart.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKillsByWeapon") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKillsByWeapon.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKillsByWeapon[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKillsByWeapon.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKillsBySituation") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKillsBySituation.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKillsBySituation[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKillsBySituation.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKillsByVictim") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKillsByVictim.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKillsByVictim[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKillsByVictim.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorDamageByBodyPart") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorDamageByBodyPart.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorDamageByBodyPart[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActorDamageByBodyPart.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorDamageByWeapon") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorDamageByWeapon.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorDamageByWeapon[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActorDamageByWeapon.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStealthSituations") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStealthSituations.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStealthSituations[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aStealthSituations.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aExplodingProps") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aExplodingProps.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aExplodingProps[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aExplodingProps.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameStats::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameStats s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKillsByBodyPart"];
	s_Object.m_aKillsByBodyPart.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aKillsByBodyPart[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKillsByWeapon"];
	s_Object.m_aKillsByWeapon.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aKillsByWeapon[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKillsBySituation"];
	s_Object.m_aKillsBySituation.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aKillsBySituation[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKillsByVictim"];
	s_Object.m_aKillsByVictim.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aKillsByVictim[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActorDamageByBodyPart"];
	s_Object.m_aActorDamageByBodyPart.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aActorDamageByBodyPart[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActorDamageByWeapon"];
	s_Object.m_aActorDamageByWeapon.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aActorDamageByWeapon[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStealthSituations"];
	s_Object.m_aStealthSituations.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aStealthSituations[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aExplodingProps"];
	s_Object.m_aExplodingProps.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aExplodingProps[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	*reinterpret_cast<SGameStats*>(p_Target) = s_Object;
}

void SGameStats::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameStats*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aKillsByBodyPart, p_Serializer, p_OwnOffset + offsetof(SGameStats, m_aKillsByBodyPart));
	TArray<int32>::Serialize(&s_Object->m_aKillsByWeapon, p_Serializer, p_OwnOffset + offsetof(SGameStats, m_aKillsByWeapon));
	TArray<int32>::Serialize(&s_Object->m_aKillsBySituation, p_Serializer, p_OwnOffset + offsetof(SGameStats, m_aKillsBySituation));
	TArray<int32>::Serialize(&s_Object->m_aKillsByVictim, p_Serializer, p_OwnOffset + offsetof(SGameStats, m_aKillsByVictim));
	TArray<int32>::Serialize(&s_Object->m_aActorDamageByBodyPart, p_Serializer, p_OwnOffset + offsetof(SGameStats, m_aActorDamageByBodyPart));
	TArray<int32>::Serialize(&s_Object->m_aActorDamageByWeapon, p_Serializer, p_OwnOffset + offsetof(SGameStats, m_aActorDamageByWeapon));
	TArray<int32>::Serialize(&s_Object->m_aStealthSituations, p_Serializer, p_OwnOffset + offsetof(SGameStats, m_aStealthSituations));
	TArray<int32>::Serialize(&s_Object->m_aExplodingProps, p_Serializer, p_OwnOffset + offsetof(SGameStats, m_aExplodingProps));
}

bool SGameStats::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameStats*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameStats*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameStats::operator==(const SGameStats& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameStats>)
		return false;

	if (m_aKillsByBodyPart != p_Other.m_aKillsByBodyPart) return false;
	if (m_aKillsByWeapon != p_Other.m_aKillsByWeapon) return false;
	if (m_aKillsBySituation != p_Other.m_aKillsBySituation) return false;
	if (m_aKillsByVictim != p_Other.m_aKillsByVictim) return false;
	if (m_aActorDamageByBodyPart != p_Other.m_aActorDamageByBodyPart) return false;
	if (m_aActorDamageByWeapon != p_Other.m_aActorDamageByWeapon) return false;
	if (m_aStealthSituations != p_Other.m_aStealthSituations) return false;
	if (m_aExplodingProps != p_Other.m_aExplodingProps) return false;

	return true;
}

ZHMTypeInfo SGameStatsData::TypeInfo = ZHMTypeInfo("SGameStatsData", sizeof(SGameStatsData), alignof(SGameStatsData), SGameStatsData::WriteJson, SGameStatsData::WriteSimpleJson, SGameStatsData::FromSimpleJson, SGameStatsData::Serialize, SGameStatsData::Equals);

void SGameStatsData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStatsData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nTotalKills") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTotalKills);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTotalShotsFired") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTotalShotsFired);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHit);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredPistol") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredPistol);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredSniper") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredSniper);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredSMG") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredSMG);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredShotgun") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredShotgun);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredAssault") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredAssault);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredRevolver") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredRevolver);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitPistol") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitPistol);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitSniper") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitSniper);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitSMG") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitSMG);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitShotgun") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitShotgun);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitAssault") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitAssault);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitRevolver") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitRevolver);
	p_Stream << "}";

	p_Stream << "}";
}

void SGameStatsData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStatsData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nTotalKills") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTotalKills);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTotalShotsFired") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTotalShotsFired);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredPistol") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredPistol);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredSniper") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredSniper);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredSMG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredSMG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredShotgun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredShotgun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredAssault") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredAssault);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsFiredRevolver") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsFiredRevolver);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitPistol") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitPistol);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitSniper") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitSniper);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitSMG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitSMG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitShotgun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitShotgun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitAssault") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitAssault);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShotsThatHitRevolver") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShotsThatHitRevolver);

	p_Stream << "}";
}

void SGameStatsData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameStatsData s_Object {};

	s_Object.m_nTotalKills = simdjson::from_json_int32(p_Document["m_nTotalKills"]);

	s_Object.m_nTotalShotsFired = simdjson::from_json_uint32(p_Document["m_nTotalShotsFired"]);

	s_Object.m_nShotsThatHit = simdjson::from_json_uint32(p_Document["m_nShotsThatHit"]);

	s_Object.m_nShotsFiredPistol = simdjson::from_json_uint32(p_Document["m_nShotsFiredPistol"]);

	s_Object.m_nShotsFiredSniper = simdjson::from_json_uint32(p_Document["m_nShotsFiredSniper"]);

	s_Object.m_nShotsFiredSMG = simdjson::from_json_uint32(p_Document["m_nShotsFiredSMG"]);

	s_Object.m_nShotsFiredShotgun = simdjson::from_json_uint32(p_Document["m_nShotsFiredShotgun"]);

	s_Object.m_nShotsFiredAssault = simdjson::from_json_uint32(p_Document["m_nShotsFiredAssault"]);

	s_Object.m_nShotsFiredRevolver = simdjson::from_json_uint32(p_Document["m_nShotsFiredRevolver"]);

	s_Object.m_nShotsThatHitPistol = simdjson::from_json_uint32(p_Document["m_nShotsThatHitPistol"]);

	s_Object.m_nShotsThatHitSniper = simdjson::from_json_uint32(p_Document["m_nShotsThatHitSniper"]);

	s_Object.m_nShotsThatHitSMG = simdjson::from_json_uint32(p_Document["m_nShotsThatHitSMG"]);

	s_Object.m_nShotsThatHitShotgun = simdjson::from_json_uint32(p_Document["m_nShotsThatHitShotgun"]);

	s_Object.m_nShotsThatHitAssault = simdjson::from_json_uint32(p_Document["m_nShotsThatHitAssault"]);

	s_Object.m_nShotsThatHitRevolver = simdjson::from_json_uint32(p_Document["m_nShotsThatHitRevolver"]);

	*reinterpret_cast<SGameStatsData*>(p_Target) = s_Object;
}

void SGameStatsData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameStatsData*>(p_Object);

}

bool SGameStatsData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameStatsData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameStatsData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameStatsData::operator==(const SGameStatsData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameStatsData>)
		return false;

	if (m_nTotalKills != p_Other.m_nTotalKills) return false;
	if (m_nTotalShotsFired != p_Other.m_nTotalShotsFired) return false;
	if (m_nShotsThatHit != p_Other.m_nShotsThatHit) return false;
	if (m_nShotsFiredPistol != p_Other.m_nShotsFiredPistol) return false;
	if (m_nShotsFiredSniper != p_Other.m_nShotsFiredSniper) return false;
	if (m_nShotsFiredSMG != p_Other.m_nShotsFiredSMG) return false;
	if (m_nShotsFiredShotgun != p_Other.m_nShotsFiredShotgun) return false;
	if (m_nShotsFiredAssault != p_Other.m_nShotsFiredAssault) return false;
	if (m_nShotsFiredRevolver != p_Other.m_nShotsFiredRevolver) return false;
	if (m_nShotsThatHitPistol != p_Other.m_nShotsThatHitPistol) return false;
	if (m_nShotsThatHitSniper != p_Other.m_nShotsThatHitSniper) return false;
	if (m_nShotsThatHitSMG != p_Other.m_nShotsThatHitSMG) return false;
	if (m_nShotsThatHitShotgun != p_Other.m_nShotsThatHitShotgun) return false;
	if (m_nShotsThatHitAssault != p_Other.m_nShotsThatHitAssault) return false;
	if (m_nShotsThatHitRevolver != p_Other.m_nShotsThatHitRevolver) return false;

	return true;
}

ZHMTypeInfo SGameStatsSaveData::TypeInfo = ZHMTypeInfo("SGameStatsSaveData", sizeof(SGameStatsSaveData), alignof(SGameStatsSaveData), SGameStatsSaveData::WriteJson, SGameStatsSaveData::WriteSimpleJson, SGameStatsSaveData::FromSimpleJson, SGameStatsSaveData::Serialize, SGameStatsSaveData::Equals);

void SGameStatsSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStatsSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_Data") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SGameStatsData") << ",\"$val\":";
	SGameStatsData::WriteJson(&s_Object->m_Data, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iPreciseSniperKillCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iPreciseSniperKillCount);
	p_Stream << "}";

	p_Stream << "}";
}

void SGameStatsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStatsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	SGameStatsData::WriteSimpleJson(&s_Object->m_Data, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iPreciseSniperKillCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iPreciseSniperKillCount);

	p_Stream << "}";
}

void SGameStatsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameStatsSaveData s_Object {};

	{
		SGameStatsData s_Item {};
		SGameStatsData::FromSimpleJson(p_Document["m_Data"], &s_Item);
		s_Object.m_Data = s_Item;
	}

	s_Object.m_iPreciseSniperKillCount = simdjson::from_json_int32(p_Document["m_iPreciseSniperKillCount"]);

	*reinterpret_cast<SGameStatsSaveData*>(p_Target) = s_Object;
}

void SGameStatsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameStatsSaveData*>(p_Object);

	SGameStatsData::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SGameStatsSaveData, m_Data));
}

bool SGameStatsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameStatsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameStatsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameStatsSaveData::operator==(const SGameStatsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameStatsSaveData>)
		return false;

	if (m_Data != p_Other.m_Data) return false;
	if (m_iPreciseSniperKillCount != p_Other.m_iPreciseSniperKillCount) return false;

	return true;
}

ZHMTypeInfo SGameStatsWeapon::TypeInfo = ZHMTypeInfo("SGameStatsWeapon", sizeof(SGameStatsWeapon), alignof(SGameStatsWeapon), SGameStatsWeapon::WriteJson, SGameStatsWeapon::WriteSimpleJson, SGameStatsWeapon::FromSimpleJson, SGameStatsWeapon::Serialize, SGameStatsWeapon::Equals);

void SGameStatsWeapon::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStatsWeapon*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eItemWeapon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("eItemType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eItemWeapon)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eItemType", static_cast<int>(s_Object->m_eItemWeapon))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_WeaponTokenID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STokenID") << ",\"$val\":";
	STokenID::WriteJson(&s_Object->m_WeaponTokenID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSpecialSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EWeaponSpecialSituation") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSpecialSituation)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EWeaponSpecialSituation", static_cast<int>(s_Object->m_eSpecialSituation))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAmmoType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("eAmmoType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAmmoType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eAmmoType", static_cast<int>(s_Object->m_eAmmoType))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void SGameStatsWeapon::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStatsWeapon*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eItemWeapon") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eItemType", static_cast<int>(s_Object->m_eItemWeapon)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_WeaponTokenID") << ":";
	STokenID::WriteSimpleJson(&s_Object->m_WeaponTokenID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSpecialSituation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EWeaponSpecialSituation", static_cast<int>(s_Object->m_eSpecialSituation)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAmmoType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eAmmoType", static_cast<int>(s_Object->m_eAmmoType)));

	p_Stream << "}";
}

void SGameStatsWeapon::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameStatsWeapon s_Object {};

	s_Object.m_eItemWeapon = static_cast<eItemType>(ZHMEnums::GetEnumValueByName("eItemType", std::string_view(p_Document["m_eItemWeapon"])));

	{
		STokenID s_Item {};
		STokenID::FromSimpleJson(p_Document["m_WeaponTokenID"], &s_Item);
		s_Object.m_WeaponTokenID = s_Item;
	}

	s_Object.m_eSpecialSituation = static_cast<EWeaponSpecialSituation>(ZHMEnums::GetEnumValueByName("EWeaponSpecialSituation", std::string_view(p_Document["m_eSpecialSituation"])));

	s_Object.m_eAmmoType = static_cast<eAmmoType>(ZHMEnums::GetEnumValueByName("eAmmoType", std::string_view(p_Document["m_eAmmoType"])));

	*reinterpret_cast<SGameStatsWeapon*>(p_Target) = s_Object;
}

void SGameStatsWeapon::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameStatsWeapon*>(p_Object);

	STokenID::Serialize(&s_Object->m_WeaponTokenID, p_Serializer, p_OwnOffset + offsetof(SGameStatsWeapon, m_WeaponTokenID));
}

bool SGameStatsWeapon::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameStatsWeapon*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameStatsWeapon*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameStatsWeapon::operator==(const SGameStatsWeapon& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameStatsWeapon>)
		return false;

	if (m_eItemWeapon != p_Other.m_eItemWeapon) return false;
	if (m_WeaponTokenID != p_Other.m_WeaponTokenID) return false;
	if (m_eSpecialSituation != p_Other.m_eSpecialSituation) return false;
	if (m_eAmmoType != p_Other.m_eAmmoType) return false;

	return true;
}

ZHMTypeInfo SLevelCPProgressionData::TypeInfo = ZHMTypeInfo("SLevelCPProgressionData", sizeof(SLevelCPProgressionData), alignof(SLevelCPProgressionData), SLevelCPProgressionData::WriteJson, SLevelCPProgressionData::WriteSimpleJson, SLevelCPProgressionData::FromSimpleJson, SLevelCPProgressionData::Serialize, SLevelCPProgressionData::Equals);

void SLevelCPProgressionData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelCPProgressionData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eLevelIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ELevelIndex") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eLevelIndex)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->m_eLevelIndex))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCPStates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCPProgressionState>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCPStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCPStates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCPProgressionState") << ",\"$val\":";
		SCPProgressionState::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aCPStates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SLevelCPProgressionData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelCPProgressionData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eLevelIndex") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->m_eLevelIndex)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCPStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCPStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCPStates[i];
		SCPProgressionState::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCPStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLevelCPProgressionData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLevelCPProgressionData s_Object {};

	s_Object.m_eLevelIndex = static_cast<ELevelIndex>(ZHMEnums::GetEnumValueByName("ELevelIndex", std::string_view(p_Document["m_eLevelIndex"])));

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCPStates"];
	s_Object.m_aCPStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCPProgressionState s_ArrayItem0;
		SCPProgressionState::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aCPStates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SLevelCPProgressionData*>(p_Target) = s_Object;
}

void SLevelCPProgressionData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLevelCPProgressionData*>(p_Object);

	TArray<SCPProgressionState>::Serialize(&s_Object->m_aCPStates, p_Serializer, p_OwnOffset + offsetof(SLevelCPProgressionData, m_aCPStates));
}

bool SLevelCPProgressionData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLevelCPProgressionData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLevelCPProgressionData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLevelCPProgressionData::operator==(const SLevelCPProgressionData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLevelCPProgressionData>)
		return false;

	if (m_eLevelIndex != p_Other.m_eLevelIndex) return false;
	if (m_aCPStates != p_Other.m_aCPStates) return false;

	return true;
}

ZHMTypeInfo SLevelProgressionData::TypeInfo = ZHMTypeInfo("SLevelProgressionData", sizeof(SLevelProgressionData), alignof(SLevelProgressionData), SLevelProgressionData::WriteJson, SLevelProgressionData::WriteSimpleJson, SLevelProgressionData::FromSimpleJson, SLevelProgressionData::Serialize, SLevelProgressionData::Equals);

void SLevelProgressionData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelProgressionData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eLevelIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ELevelIndex") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eLevelIndex)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->m_eLevelIndex))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCheckpointIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCheckpointIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDifficulty") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDifficulty);
	p_Stream << "}";

	p_Stream << "}";
}

void SLevelProgressionData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelProgressionData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eLevelIndex") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->m_eLevelIndex)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCheckpointIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCheckpointIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDifficulty") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDifficulty);

	p_Stream << "}";
}

void SLevelProgressionData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLevelProgressionData s_Object {};

	s_Object.m_eLevelIndex = static_cast<ELevelIndex>(ZHMEnums::GetEnumValueByName("ELevelIndex", std::string_view(p_Document["m_eLevelIndex"])));

	s_Object.m_nCheckpointIndex = simdjson::from_json_int32(p_Document["m_nCheckpointIndex"]);

	s_Object.m_nDifficulty = simdjson::from_json_int32(p_Document["m_nDifficulty"]);

	*reinterpret_cast<SLevelProgressionData*>(p_Target) = s_Object;
}

void SLevelProgressionData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLevelProgressionData*>(p_Object);

}

bool SLevelProgressionData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLevelProgressionData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLevelProgressionData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLevelProgressionData::operator==(const SLevelProgressionData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLevelProgressionData>)
		return false;

	if (m_eLevelIndex != p_Other.m_eLevelIndex) return false;
	if (m_nCheckpointIndex != p_Other.m_nCheckpointIndex) return false;
	if (m_nDifficulty != p_Other.m_nDifficulty) return false;

	return true;
}

ZHMTypeInfo SLevelSaveData::TypeInfo = ZHMTypeInfo("SLevelSaveData", sizeof(SLevelSaveData), alignof(SLevelSaveData), SLevelSaveData::WriteJson, SLevelSaveData::WriteSimpleJson, SLevelSaveData::FromSimpleJson, SLevelSaveData::Serialize, SLevelSaveData::Equals);

void SLevelSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_LevelID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ELevelIndex") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_LevelID)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->m_LevelID))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CheckpointData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCheckpointSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CheckpointData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CheckpointData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCheckpointSaveData") << ",\"$val\":";
		SCheckpointSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_CheckpointData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SLevelSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_LevelID") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ELevelIndex", static_cast<int>(s_Object->m_LevelID)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CheckpointData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CheckpointData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CheckpointData[i];
		SCheckpointSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CheckpointData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLevelSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLevelSaveData s_Object {};

	s_Object.m_LevelID = static_cast<ELevelIndex>(ZHMEnums::GetEnumValueByName("ELevelIndex", std::string_view(p_Document["m_LevelID"])));

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CheckpointData"];
	s_Object.m_CheckpointData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCheckpointSaveData s_ArrayItem0;
		SCheckpointSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_CheckpointData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SLevelSaveData*>(p_Target) = s_Object;
}

void SLevelSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLevelSaveData*>(p_Object);

	TArray<SCheckpointSaveData>::Serialize(&s_Object->m_CheckpointData, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_CheckpointData));
}

bool SLevelSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLevelSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLevelSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLevelSaveData::operator==(const SLevelSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLevelSaveData>)
		return false;

	if (m_LevelID != p_Other.m_LevelID) return false;
	if (m_CheckpointData != p_Other.m_CheckpointData) return false;

	return true;
}

ZHMTypeInfo SLoadRuntimeResourceResult::TypeInfo = ZHMTypeInfo("SLoadRuntimeResourceResult", sizeof(SLoadRuntimeResourceResult), alignof(SLoadRuntimeResourceResult), SLoadRuntimeResourceResult::WriteJson, SLoadRuntimeResourceResult::WriteSimpleJson, SLoadRuntimeResourceResult::FromSimpleJson, SLoadRuntimeResourceResult::Serialize, SLoadRuntimeResourceResult::Equals);

void SLoadRuntimeResourceResult::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sFilePath") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sFilePath);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sOutputMessage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sOutputMessage);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sErrorMessage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sErrorMessage);
	p_Stream << "}";

	p_Stream << "}";
}

void SLoadRuntimeResourceResult::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFilePath") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFilePath);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sOutputMessage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sOutputMessage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sErrorMessage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sErrorMessage);

	p_Stream << "}";
}

void SLoadRuntimeResourceResult::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLoadRuntimeResourceResult s_Object {};

	s_Object.sFilePath = std::string_view(p_Document["sFilePath"]);

	s_Object.sOutputMessage = std::string_view(p_Document["sOutputMessage"]);

	s_Object.sErrorMessage = std::string_view(p_Document["sErrorMessage"]);

	*reinterpret_cast<SLoadRuntimeResourceResult*>(p_Target) = s_Object;
}

void SLoadRuntimeResourceResult::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	ZString::Serialize(&s_Object->sFilePath, p_Serializer, p_OwnOffset + offsetof(SLoadRuntimeResourceResult, sFilePath));
	ZString::Serialize(&s_Object->sOutputMessage, p_Serializer, p_OwnOffset + offsetof(SLoadRuntimeResourceResult, sOutputMessage));
	ZString::Serialize(&s_Object->sErrorMessage, p_Serializer, p_OwnOffset + offsetof(SLoadRuntimeResourceResult, sErrorMessage));
}

bool SLoadRuntimeResourceResult::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Left);
	auto* s_Right = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLoadRuntimeResourceResult::operator==(const SLoadRuntimeResourceResult& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLoadRuntimeResourceResult>)
		return false;

	if (sFilePath != p_Other.sFilePath) return false;
	if (sOutputMessage != p_Other.sOutputMessage) return false;
	if (sErrorMessage != p_Other.sErrorMessage) return false;

	return true;
}

ZHMTypeInfo SMatrix33::TypeInfo = ZHMTypeInfo("SMatrix33", sizeof(SMatrix33), alignof(SMatrix33), SMatrix33::WriteJson, SMatrix33::WriteSimpleJson, SMatrix33::FromSimpleJson, SMatrix33::Serialize, SMatrix33::Equals);

void SMatrix33::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("XAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->XAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->YAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->ZAxis, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SMatrix33::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->ZAxis, p_Stream);

	p_Stream << "}";
}

void SMatrix33::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix33 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["XAxis"], &s_Item);
		s_Object.XAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["YAxis"], &s_Item);
		s_Object.YAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["ZAxis"], &s_Item);
		s_Object.ZAxis = s_Item;
	}

	*reinterpret_cast<SMatrix33*>(p_Target) = s_Object;
}

void SMatrix33::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	SVector3::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, XAxis));
	SVector3::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, YAxis));
	SVector3::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, ZAxis));
}

bool SMatrix33::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix33*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix33*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix33::operator==(const SMatrix33& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix33>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;

	return true;
}

ZHMTypeInfo SMatrix43::TypeInfo = ZHMTypeInfo("SMatrix43", sizeof(SMatrix43), alignof(SMatrix43), SMatrix43::WriteJson, SMatrix43::WriteSimpleJson, SMatrix43::FromSimpleJson, SMatrix43::Serialize, SMatrix43::Equals);

void SMatrix43::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("XAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->XAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->YAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->ZAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->Trans, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SMatrix43::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->ZAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	SVector3::WriteSimpleJson(&s_Object->Trans, p_Stream);

	p_Stream << "}";
}

void SMatrix43::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix43 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["XAxis"], &s_Item);
		s_Object.XAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["YAxis"], &s_Item);
		s_Object.YAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["ZAxis"], &s_Item);
		s_Object.ZAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["Trans"], &s_Item);
		s_Object.Trans = s_Item;
	}

	*reinterpret_cast<SMatrix43*>(p_Target) = s_Object;
}

void SMatrix43::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	SVector3::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, XAxis));
	SVector3::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, YAxis));
	SVector3::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, ZAxis));
	SVector3::Serialize(&s_Object->Trans, p_Serializer, p_OwnOffset + offsetof(SMatrix43, Trans));
}

bool SMatrix43::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix43*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix43*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix43::operator==(const SMatrix43& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix43>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;
	if (Trans != p_Other.Trans) return false;

	return true;
}

ZHMTypeInfo SMatrix44::TypeInfo = ZHMTypeInfo("SMatrix44", sizeof(SMatrix44), alignof(SMatrix44), SMatrix44::WriteJson, SMatrix44::WriteSimpleJson, SMatrix44::FromSimpleJson, SMatrix44::Serialize, SMatrix44::Equals);

void SMatrix44::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m11") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m11);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m12") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m12);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m13") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m13);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m14") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m14);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m21") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m21);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m22") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m22);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m23") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m23);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m24") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m24);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m31") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m31);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m32") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m32);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m33") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m33);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m34") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m34);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m41") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m41);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m42") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m42);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m43") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m43);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m44") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m44);
	p_Stream << "}";

	p_Stream << "}";
}

void SMatrix44::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m11") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m11);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m12") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m12);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m13") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m13);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m14") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m14);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m21") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m21);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m22") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m22);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m23") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m23);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m24") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m24);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m31") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m31);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m32") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m32);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m33") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m33);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m34") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m34);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m41") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m41);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m42") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m42);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m43") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m43);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m44") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m44);

	p_Stream << "}";
}

void SMatrix44::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix44 s_Object {};

	s_Object.m11 = simdjson::from_json_float32(p_Document["m11"]);

	s_Object.m12 = simdjson::from_json_float32(p_Document["m12"]);

	s_Object.m13 = simdjson::from_json_float32(p_Document["m13"]);

	s_Object.m14 = simdjson::from_json_float32(p_Document["m14"]);

	s_Object.m21 = simdjson::from_json_float32(p_Document["m21"]);

	s_Object.m22 = simdjson::from_json_float32(p_Document["m22"]);

	s_Object.m23 = simdjson::from_json_float32(p_Document["m23"]);

	s_Object.m24 = simdjson::from_json_float32(p_Document["m24"]);

	s_Object.m31 = simdjson::from_json_float32(p_Document["m31"]);

	s_Object.m32 = simdjson::from_json_float32(p_Document["m32"]);

	s_Object.m33 = simdjson::from_json_float32(p_Document["m33"]);

	s_Object.m34 = simdjson::from_json_float32(p_Document["m34"]);

	s_Object.m41 = simdjson::from_json_float32(p_Document["m41"]);

	s_Object.m42 = simdjson::from_json_float32(p_Document["m42"]);

	s_Object.m43 = simdjson::from_json_float32(p_Document["m43"]);

	s_Object.m44 = simdjson::from_json_float32(p_Document["m44"]);

	*reinterpret_cast<SMatrix44*>(p_Target) = s_Object;
}

void SMatrix44::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

}

bool SMatrix44::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix44*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix44*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix44::operator==(const SMatrix44& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix44>)
		return false;

	if (m11 != p_Other.m11) return false;
	if (m12 != p_Other.m12) return false;
	if (m13 != p_Other.m13) return false;
	if (m14 != p_Other.m14) return false;
	if (m21 != p_Other.m21) return false;
	if (m22 != p_Other.m22) return false;
	if (m23 != p_Other.m23) return false;
	if (m24 != p_Other.m24) return false;
	if (m31 != p_Other.m31) return false;
	if (m32 != p_Other.m32) return false;
	if (m33 != p_Other.m33) return false;
	if (m34 != p_Other.m34) return false;
	if (m41 != p_Other.m41) return false;
	if (m42 != p_Other.m42) return false;
	if (m43 != p_Other.m43) return false;
	if (m44 != p_Other.m44) return false;

	return true;
}

ZHMTypeInfo SMiscSaveData::TypeInfo = ZHMTypeInfo("SMiscSaveData", sizeof(SMiscSaveData), alignof(SMiscSaveData), SMiscSaveData::WriteJson, SMiscSaveData::WriteSimpleJson, SMiscSaveData::FromSimpleJson, SMiscSaveData::Serialize, SMiscSaveData::Equals);

void SMiscSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMiscSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bCompletedFirstBoot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompletedFirstBoot);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bContractsTutorialPlayShown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bContractsTutorialPlayShown);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bContractsTutorialCreateShown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bContractsTutorialCreateShown);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastUnlockedOutfit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STokenID") << ",\"$val\":";
	STokenID::WriteJson(&s_Object->m_LastUnlockedOutfit, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastUnlockedWeapon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STokenID") << ",\"$val\":";
	STokenID::WriteJson(&s_Object->m_LastUnlockedWeapon, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iPOIProgressPointsWhenUnlockKeyMesageDisplayed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iPOIProgressPointsWhenUnlockKeyMesageDisplayed);
	p_Stream << "}";

	p_Stream << "}";
}

void SMiscSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMiscSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bCompletedFirstBoot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompletedFirstBoot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bContractsTutorialPlayShown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bContractsTutorialPlayShown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bContractsTutorialCreateShown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bContractsTutorialCreateShown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastUnlockedOutfit") << ":";
	STokenID::WriteSimpleJson(&s_Object->m_LastUnlockedOutfit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastUnlockedWeapon") << ":";
	STokenID::WriteSimpleJson(&s_Object->m_LastUnlockedWeapon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iPOIProgressPointsWhenUnlockKeyMesageDisplayed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iPOIProgressPointsWhenUnlockKeyMesageDisplayed);

	p_Stream << "}";
}

void SMiscSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMiscSaveData s_Object {};

	s_Object.m_bCompletedFirstBoot = simdjson::from_json_bool(p_Document["m_bCompletedFirstBoot"]);

	s_Object.m_bContractsTutorialPlayShown = simdjson::from_json_bool(p_Document["m_bContractsTutorialPlayShown"]);

	s_Object.m_bContractsTutorialCreateShown = simdjson::from_json_bool(p_Document["m_bContractsTutorialCreateShown"]);

	{
		STokenID s_Item {};
		STokenID::FromSimpleJson(p_Document["m_LastUnlockedOutfit"], &s_Item);
		s_Object.m_LastUnlockedOutfit = s_Item;
	}

	{
		STokenID s_Item {};
		STokenID::FromSimpleJson(p_Document["m_LastUnlockedWeapon"], &s_Item);
		s_Object.m_LastUnlockedWeapon = s_Item;
	}

	s_Object.m_iPOIProgressPointsWhenUnlockKeyMesageDisplayed = simdjson::from_json_uint32(p_Document["m_iPOIProgressPointsWhenUnlockKeyMesageDisplayed"]);

	*reinterpret_cast<SMiscSaveData*>(p_Target) = s_Object;
}

void SMiscSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMiscSaveData*>(p_Object);

	STokenID::Serialize(&s_Object->m_LastUnlockedOutfit, p_Serializer, p_OwnOffset + offsetof(SMiscSaveData, m_LastUnlockedOutfit));
	STokenID::Serialize(&s_Object->m_LastUnlockedWeapon, p_Serializer, p_OwnOffset + offsetof(SMiscSaveData, m_LastUnlockedWeapon));
}

bool SMiscSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMiscSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMiscSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMiscSaveData::operator==(const SMiscSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMiscSaveData>)
		return false;

	if (m_bCompletedFirstBoot != p_Other.m_bCompletedFirstBoot) return false;
	if (m_bContractsTutorialPlayShown != p_Other.m_bContractsTutorialPlayShown) return false;
	if (m_bContractsTutorialCreateShown != p_Other.m_bContractsTutorialCreateShown) return false;
	if (m_LastUnlockedOutfit != p_Other.m_LastUnlockedOutfit) return false;
	if (m_LastUnlockedWeapon != p_Other.m_LastUnlockedWeapon) return false;
	if (m_iPOIProgressPointsWhenUnlockKeyMesageDisplayed != p_Other.m_iPOIProgressPointsWhenUnlockKeyMesageDisplayed) return false;

	return true;
}

ZHMTypeInfo SNRange::TypeInfo = ZHMTypeInfo("SNRange", sizeof(SNRange), alignof(SNRange), SNRange::WriteJson, SNRange::WriteSimpleJson, SNRange::FromSimpleJson, SNRange::Serialize, SNRange::Equals);

void SNRange::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SNRange*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nMin") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMin);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMax);
	p_Stream << "}";

	p_Stream << "}";
}

void SNRange::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SNRange*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nMin") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMin);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMax);

	p_Stream << "}";
}

void SNRange::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SNRange s_Object {};

	s_Object.m_nMin = simdjson::from_json_int32(p_Document["m_nMin"]);

	s_Object.m_nMax = simdjson::from_json_int32(p_Document["m_nMax"]);

	*reinterpret_cast<SNRange*>(p_Target) = s_Object;
}

void SNRange::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SNRange*>(p_Object);

}

bool SNRange::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SNRange*>(p_Left);
	auto* s_Right = reinterpret_cast<SNRange*>(p_Right);

	return *s_Left == *s_Right;
}

bool SNRange::operator==(const SNRange& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SNRange>)
		return false;

	if (m_nMin != p_Other.m_nMin) return false;
	if (m_nMax != p_Other.m_nMax) return false;

	return true;
}

ZHMTypeInfo SPOISaveData::TypeInfo = ZHMTypeInfo("SPOISaveData", sizeof(SPOISaveData), alignof(SPOISaveData), SPOISaveData::WriteJson, SPOISaveData::WriteSimpleJson, SPOISaveData::FromSimpleJson, SPOISaveData::Serialize, SPOISaveData::Equals);

void SPOISaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPOISaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nProgressionPoints") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nProgressionPoints);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLoaded") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLoaded);
	p_Stream << "}";

	p_Stream << "}";
}

void SPOISaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPOISaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nProgressionPoints") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nProgressionPoints);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLoaded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLoaded);

	p_Stream << "}";
}

void SPOISaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPOISaveData s_Object {};

	s_Object.m_nProgressionPoints = simdjson::from_json_int32(p_Document["m_nProgressionPoints"]);

	s_Object.m_bLoaded = simdjson::from_json_bool(p_Document["m_bLoaded"]);

	*reinterpret_cast<SPOISaveData*>(p_Target) = s_Object;
}

void SPOISaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPOISaveData*>(p_Object);

}

bool SPOISaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPOISaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPOISaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPOISaveData::operator==(const SPOISaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPOISaveData>)
		return false;

	if (m_nProgressionPoints != p_Other.m_nProgressionPoints) return false;
	if (m_bLoaded != p_Other.m_bLoaded) return false;

	return true;
}

ZHMTypeInfo SRatingData::TypeInfo = ZHMTypeInfo("SRatingData", sizeof(SRatingData), alignof(SRatingData), SRatingData::WriteJson, SRatingData::WriteSimpleJson, SRatingData::FromSimpleJson, SRatingData::Serialize, SRatingData::Equals);

void SRatingData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRatingData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_CheckpointStyles") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CheckpointStyles.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CheckpointStyles[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_CheckpointStyles.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TitlesAchieved") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_TitlesAchieved.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_TitlesAchieved[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_TitlesAchieved.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TitlesViewed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_TitlesViewed.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_TitlesViewed[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_TitlesViewed.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CPDifficulty") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<DifficultyLevelEnum>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CPDifficulty.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CPDifficulty[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("DifficultyLevelEnum") << ",\"$val\":";
		p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Item0)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("DifficultyLevelEnum", static_cast<int>(s_Item0))) << "}";
		p_Stream << "}";

		if (i < s_Object->m_CPDifficulty.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CPChallenges") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CPChallenges.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CPChallenges[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_CPChallenges.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iLastUnlockedTitle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iLastUnlockedTitle);
	p_Stream << "}";

	p_Stream << "}";
}

void SRatingData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRatingData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CheckpointStyles") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CheckpointStyles.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CheckpointStyles[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_CheckpointStyles.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TitlesAchieved") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_TitlesAchieved.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_TitlesAchieved[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_TitlesAchieved.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TitlesViewed") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_TitlesViewed.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_TitlesViewed[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_TitlesViewed.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CPDifficulty") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CPDifficulty.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CPDifficulty[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("DifficultyLevelEnum", static_cast<int>(s_Item0)));

		if (i < s_Object->m_CPDifficulty.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CPChallenges") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CPChallenges.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CPChallenges[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_CPChallenges.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iLastUnlockedTitle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iLastUnlockedTitle);

	p_Stream << "}";
}

void SRatingData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRatingData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CheckpointStyles"];
	s_Object.m_CheckpointStyles.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_CheckpointStyles[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_TitlesAchieved"];
	s_Object.m_TitlesAchieved.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_TitlesAchieved[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_TitlesViewed"];
	s_Object.m_TitlesViewed.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_TitlesViewed[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CPDifficulty"];
	s_Object.m_CPDifficulty.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_CPDifficulty[s_Index0++] = static_cast<DifficultyLevelEnum>(ZHMEnums::GetEnumValueByName("DifficultyLevelEnum", std::string_view(s_Item0)));
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CPChallenges"];
	s_Object.m_CPChallenges.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_CPChallenges[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	s_Object.m_iLastUnlockedTitle = simdjson::from_json_int32(p_Document["m_iLastUnlockedTitle"]);

	*reinterpret_cast<SRatingData*>(p_Target) = s_Object;
}

void SRatingData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRatingData*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_CheckpointStyles, p_Serializer, p_OwnOffset + offsetof(SRatingData, m_CheckpointStyles));
	TArray<bool>::Serialize(&s_Object->m_TitlesAchieved, p_Serializer, p_OwnOffset + offsetof(SRatingData, m_TitlesAchieved));
	TArray<bool>::Serialize(&s_Object->m_TitlesViewed, p_Serializer, p_OwnOffset + offsetof(SRatingData, m_TitlesViewed));
	TArray<DifficultyLevelEnum>::Serialize(&s_Object->m_CPDifficulty, p_Serializer, p_OwnOffset + offsetof(SRatingData, m_CPDifficulty));
	TArray<int32>::Serialize(&s_Object->m_CPChallenges, p_Serializer, p_OwnOffset + offsetof(SRatingData, m_CPChallenges));
}

bool SRatingData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRatingData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRatingData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRatingData::operator==(const SRatingData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRatingData>)
		return false;

	if (m_CheckpointStyles != p_Other.m_CheckpointStyles) return false;
	if (m_TitlesAchieved != p_Other.m_TitlesAchieved) return false;
	if (m_TitlesViewed != p_Other.m_TitlesViewed) return false;
	if (m_CPDifficulty != p_Other.m_CPDifficulty) return false;
	if (m_CPChallenges != p_Other.m_CPChallenges) return false;
	if (m_iLastUnlockedTitle != p_Other.m_iLastUnlockedTitle) return false;

	return true;
}

ZHMTypeInfo SRatingHighScoreData::TypeInfo = ZHMTypeInfo("SRatingHighScoreData", sizeof(SRatingHighScoreData), alignof(SRatingHighScoreData), SRatingHighScoreData::WriteJson, SRatingHighScoreData::WriteSimpleJson, SRatingHighScoreData::FromSimpleJson, SRatingHighScoreData::Serialize, SRatingHighScoreData::Equals);

void SRatingHighScoreData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRatingHighScoreData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_HighScores") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_HighScores.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_HighScores[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_HighScores.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighTitles") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_HighTitles.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_HighTitles[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_HighTitles.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SRatingHighScoreData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRatingHighScoreData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_HighScores") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_HighScores.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_HighScores[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_HighScores.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighTitles") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_HighTitles.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_HighTitles[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_HighTitles.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SRatingHighScoreData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRatingHighScoreData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_HighScores"];
	s_Object.m_HighScores.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_HighScores[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_HighTitles"];
	s_Object.m_HighTitles.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_HighTitles[s_Index0++] = simdjson::from_json_int8(s_Item0);
	}
	}

	*reinterpret_cast<SRatingHighScoreData*>(p_Target) = s_Object;
}

void SRatingHighScoreData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRatingHighScoreData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_HighScores, p_Serializer, p_OwnOffset + offsetof(SRatingHighScoreData, m_HighScores));
	TArray<int8>::Serialize(&s_Object->m_HighTitles, p_Serializer, p_OwnOffset + offsetof(SRatingHighScoreData, m_HighTitles));
}

bool SRatingHighScoreData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRatingHighScoreData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRatingHighScoreData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRatingHighScoreData::operator==(const SRatingHighScoreData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRatingHighScoreData>)
		return false;

	if (m_HighScores != p_Other.m_HighScores) return false;
	if (m_HighTitles != p_Other.m_HighTitles) return false;

	return true;
}

ZHMTypeInfo ZBitArray::TypeInfo = ZHMTypeInfo("ZBitArray", sizeof(ZBitArray), alignof(ZBitArray), ZBitArray::WriteJson, ZBitArray::WriteSimpleJson, ZBitArray::FromSimpleJson, ZBitArray::Serialize, ZBitArray::Equals);

void ZBitArray::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aBytes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBytes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBytes[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aBytes.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSize);
	p_Stream << "}";

	p_Stream << "}";
}

void ZBitArray::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBytes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBytes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBytes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBytes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSize);

	p_Stream << "}";
}

void ZBitArray::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZBitArray s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBytes"];
	s_Object.m_aBytes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aBytes[s_Index0++] = simdjson::from_json_uint8(s_Item0);
	}
	}

	s_Object.m_nSize = simdjson::from_json_uint32(p_Document["m_nSize"]);

	*reinterpret_cast<ZBitArray*>(p_Target) = s_Object;
}

void ZBitArray::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	TArray<uint8>::Serialize(&s_Object->m_aBytes, p_Serializer, p_OwnOffset + offsetof(ZBitArray, m_aBytes));
}

bool ZBitArray::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZBitArray*>(p_Left);
	auto* s_Right = reinterpret_cast<ZBitArray*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZBitArray::operator==(const ZBitArray& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZBitArray>)
		return false;

	if (m_aBytes != p_Other.m_aBytes) return false;
	if (m_nSize != p_Other.m_nSize) return false;

	return true;
}

ZHMTypeInfo SReasoningGrid::TypeInfo = ZHMTypeInfo("SReasoningGrid", sizeof(SReasoningGrid), alignof(SReasoningGrid), SReasoningGrid::WriteJson, SReasoningGrid::WriteSimpleJson, SReasoningGrid::FromSimpleJson, SReasoningGrid::Serialize, SReasoningGrid::Equals);

void SReasoningGrid::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_WaypointList") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SGWaypoint>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_WaypointList.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_WaypointList[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SGWaypoint") << ",\"$val\":";
		SGWaypoint::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_WaypointList.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LowVisibilityBits") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZBitArray") << ",\"$val\":";
	ZBitArray::WriteJson(&s_Object->m_LowVisibilityBits, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighVisibilityBits") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZBitArray") << ",\"$val\":";
	ZBitArray::WriteJson(&s_Object->m_HighVisibilityBits, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LowVisibility") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TArray<uint16>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_LowVisibility.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_LowVisibility[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
			p_Stream << simdjson::as_json_string(s_Item1);
			p_Stream << "}";

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}
		p_Stream << "]";
		p_Stream << "}";

		if (i < s_Object->m_LowVisibility.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighVisibility") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TArray<uint16>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_HighVisibility.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_HighVisibility[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
			p_Stream << simdjson::as_json_string(s_Item1);
			p_Stream << "}";

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}
		p_Stream << "]";
		p_Stream << "}";

		if (i < s_Object->m_HighVisibility.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Properties") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SGProperties") << ",\"$val\":";
	SGProperties::WriteJson(&s_Object->m_Properties, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BitVisibilityCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_BitVisibilityCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNodeCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNodeCount);
	p_Stream << "}";

	p_Stream << "}";
}

void SReasoningGrid::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_WaypointList") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_WaypointList.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_WaypointList[i];
		SGWaypoint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_WaypointList.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LowVisibilityBits") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_LowVisibilityBits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighVisibilityBits") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_HighVisibilityBits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LowVisibility") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_LowVisibility.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_LowVisibility[i];
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << simdjson::as_json_string(s_Item1);

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}

		p_Stream << "]";

		if (i < s_Object->m_LowVisibility.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighVisibility") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_HighVisibility.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_HighVisibility[i];
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << simdjson::as_json_string(s_Item1);

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}

		p_Stream << "]";

		if (i < s_Object->m_HighVisibility.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Properties") << ":";
	SGProperties::WriteSimpleJson(&s_Object->m_Properties, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BitVisibilityCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_BitVisibilityCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNodeCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNodeCount);

	p_Stream << "}";
}

void SReasoningGrid::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SReasoningGrid s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_WaypointList"];
	s_Object.m_WaypointList.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SGWaypoint s_ArrayItem0;
		SGWaypoint::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_WaypointList[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		ZBitArray s_Item {};
		ZBitArray::FromSimpleJson(p_Document["m_LowVisibilityBits"], &s_Item);
		s_Object.m_LowVisibilityBits = s_Item;
	}

	{
		ZBitArray s_Item {};
		ZBitArray::FromSimpleJson(p_Document["m_HighVisibilityBits"], &s_Item);
		s_Object.m_HighVisibilityBits = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_LowVisibility"];
	s_Object.m_LowVisibility.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TArray<uint16> s_ArrayItem0;
		{
		simdjson::ondemand::array s_Array1 = s_Item0;
		s_ArrayItem0.resize(s_Array1.count_elements());
		size_t s_Index1 = 0;

		for (simdjson::ondemand::value s_Item1 : s_Array1)
		{
			s_ArrayItem0[s_Index1++] = simdjson::from_json_uint16(s_Item1);
		}
		}
		s_Object.m_LowVisibility[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_HighVisibility"];
	s_Object.m_HighVisibility.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TArray<uint16> s_ArrayItem0;
		{
		simdjson::ondemand::array s_Array1 = s_Item0;
		s_ArrayItem0.resize(s_Array1.count_elements());
		size_t s_Index1 = 0;

		for (simdjson::ondemand::value s_Item1 : s_Array1)
		{
			s_ArrayItem0[s_Index1++] = simdjson::from_json_uint16(s_Item1);
		}
		}
		s_Object.m_HighVisibility[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		SGProperties s_Item {};
		SGProperties::FromSimpleJson(p_Document["m_Properties"], &s_Item);
		s_Object.m_Properties = s_Item;
	}

	s_Object.m_BitVisibilityCount = simdjson::from_json_uint32(p_Document["m_BitVisibilityCount"]);

	s_Object.m_nNodeCount = simdjson::from_json_uint32(p_Document["m_nNodeCount"]);

	*reinterpret_cast<SReasoningGrid*>(p_Target) = s_Object;
}

void SReasoningGrid::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	TArray<SGWaypoint>::Serialize(&s_Object->m_WaypointList, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_WaypointList));
	ZBitArray::Serialize(&s_Object->m_LowVisibilityBits, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_LowVisibilityBits));
	ZBitArray::Serialize(&s_Object->m_HighVisibilityBits, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_HighVisibilityBits));
	TArray<TArray<uint16>>::Serialize(&s_Object->m_LowVisibility, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_LowVisibility));
	TArray<TArray<uint16>>::Serialize(&s_Object->m_HighVisibility, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_HighVisibility));
	SGProperties::Serialize(&s_Object->m_Properties, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_Properties));
}

bool SReasoningGrid::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SReasoningGrid*>(p_Left);
	auto* s_Right = reinterpret_cast<SReasoningGrid*>(p_Right);

	return *s_Left == *s_Right;
}

bool SReasoningGrid::operator==(const SReasoningGrid& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SReasoningGrid>)
		return false;

	if (m_WaypointList != p_Other.m_WaypointList) return false;
	if (m_LowVisibilityBits != p_Other.m_LowVisibilityBits) return false;
	if (m_HighVisibilityBits != p_Other.m_HighVisibilityBits) return false;
	if (m_LowVisibility != p_Other.m_LowVisibility) return false;
	if (m_HighVisibility != p_Other.m_HighVisibility) return false;
	if (m_Properties != p_Other.m_Properties) return false;
	if (m_BitVisibilityCount != p_Other.m_BitVisibilityCount) return false;
	if (m_nNodeCount != p_Other.m_nNodeCount) return false;

	return true;
}

ZHMTypeInfo SSerializedValue::TypeInfo = ZHMTypeInfo("SSerializedValue", sizeof(SSerializedValue), alignof(SSerializedValue), SSerializedValue::WriteJson, SSerializedValue::WriteSimpleJson, SSerializedValue::FromSimpleJson, SSerializedValue::Serialize, SSerializedValue::Equals);

void SSerializedValue::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SSerializedValue::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SSerializedValue::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSerializedValue s_Object {};

	*reinterpret_cast<SSerializedValue*>(p_Target) = s_Object;
}

void SSerializedValue::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

}

bool SSerializedValue::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSerializedValue*>(p_Left);
	auto* s_Right = reinterpret_cast<SSerializedValue*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSerializedValue::operator==(const SSerializedValue& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSerializedValue>)
		return false;


	return true;
}

ZHMTypeInfo SSettingsParamMultiplier::TypeInfo = ZHMTypeInfo("SSettingsParamMultiplier", sizeof(SSettingsParamMultiplier), alignof(SSettingsParamMultiplier), SSettingsParamMultiplier::WriteJson, SSettingsParamMultiplier::WriteSimpleJson, SSettingsParamMultiplier::FromSimpleJson, SSettingsParamMultiplier::Serialize, SSettingsParamMultiplier::Equals);

void SSettingsParamMultiplier::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eSettingsParam") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ESettingsParam") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSettingsParam)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESettingsParam", static_cast<int>(s_Object->m_eSettingsParam))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMultiplier);
	p_Stream << "}";

	p_Stream << "}";
}

void SSettingsParamMultiplier::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSettingsParam") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESettingsParam", static_cast<int>(s_Object->m_eSettingsParam)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMultiplier);

	p_Stream << "}";
}

void SSettingsParamMultiplier::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSettingsParamMultiplier s_Object {};

	s_Object.m_eSettingsParam = static_cast<ESettingsParam>(ZHMEnums::GetEnumValueByName("ESettingsParam", std::string_view(p_Document["m_eSettingsParam"])));

	s_Object.m_fMultiplier = simdjson::from_json_float32(p_Document["m_fMultiplier"]);

	*reinterpret_cast<SSettingsParamMultiplier*>(p_Target) = s_Object;
}

void SSettingsParamMultiplier::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Object);

}

bool SSettingsParamMultiplier::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSettingsParamMultiplier*>(p_Left);
	auto* s_Right = reinterpret_cast<SSettingsParamMultiplier*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSettingsParamMultiplier::operator==(const SSettingsParamMultiplier& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSettingsParamMultiplier>)
		return false;

	if (m_eSettingsParam != p_Other.m_eSettingsParam) return false;
	if (m_fMultiplier != p_Other.m_fMultiplier) return false;

	return true;
}

ZHMTypeInfo STechniqueUnlockState::TypeInfo = ZHMTypeInfo("STechniqueUnlockState", sizeof(STechniqueUnlockState), alignof(STechniqueUnlockState), STechniqueUnlockState::WriteJson, STechniqueUnlockState::WriteSimpleJson, STechniqueUnlockState::FromSimpleJson, STechniqueUnlockState::Serialize, STechniqueUnlockState::Equals);

void STechniqueUnlockState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STechniqueUnlockState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_CheckpointTokenID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STokenID") << ",\"$val\":";
	STokenID::WriteJson(&s_Object->m_CheckpointTokenID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTechnique") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("HMTechniques.ETechnique") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTechnique)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("HMTechniques.ETechnique", static_cast<int>(s_Object->m_eTechnique))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iLevel") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iLevel);
	p_Stream << "}";

	p_Stream << "}";
}

void STechniqueUnlockState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STechniqueUnlockState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CheckpointTokenID") << ":";
	STokenID::WriteSimpleJson(&s_Object->m_CheckpointTokenID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTechnique") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("HMTechniques.ETechnique", static_cast<int>(s_Object->m_eTechnique)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iLevel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iLevel);

	p_Stream << "}";
}

void STechniqueUnlockState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STechniqueUnlockState s_Object {};

	{
		STokenID s_Item {};
		STokenID::FromSimpleJson(p_Document["m_CheckpointTokenID"], &s_Item);
		s_Object.m_CheckpointTokenID = s_Item;
	}

	s_Object.m_eTechnique = static_cast<HMTechniques_ETechnique>(ZHMEnums::GetEnumValueByName("HMTechniques.ETechnique", std::string_view(p_Document["m_eTechnique"])));

	s_Object.m_iLevel = simdjson::from_json_int32(p_Document["m_iLevel"]);

	*reinterpret_cast<STechniqueUnlockState*>(p_Target) = s_Object;
}

void STechniqueUnlockState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STechniqueUnlockState*>(p_Object);

	STokenID::Serialize(&s_Object->m_CheckpointTokenID, p_Serializer, p_OwnOffset + offsetof(STechniqueUnlockState, m_CheckpointTokenID));
}

bool STechniqueUnlockState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STechniqueUnlockState*>(p_Left);
	auto* s_Right = reinterpret_cast<STechniqueUnlockState*>(p_Right);

	return *s_Left == *s_Right;
}

bool STechniqueUnlockState::operator==(const STechniqueUnlockState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STechniqueUnlockState>)
		return false;

	if (m_CheckpointTokenID != p_Other.m_CheckpointTokenID) return false;
	if (m_eTechnique != p_Other.m_eTechnique) return false;
	if (m_iLevel != p_Other.m_iLevel) return false;

	return true;
}

ZHMTypeInfo STechniquesSaveData::TypeInfo = ZHMTypeInfo("STechniquesSaveData", sizeof(STechniquesSaveData), alignof(STechniquesSaveData), STechniquesSaveData::WriteJson, STechniquesSaveData::WriteSimpleJson, STechniquesSaveData::FromSimpleJson, STechniquesSaveData::Serialize, STechniquesSaveData::Equals);

void STechniquesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STechniquesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iTechniqueUnlockedLevel") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TFixedArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_iTechniqueUnlockedLevel.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_iTechniqueUnlockedLevel[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_iTechniqueUnlockedLevel.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aUnlockState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STechniqueUnlockState>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aUnlockState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aUnlockState[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STechniqueUnlockState") << ",\"$val\":";
		STechniqueUnlockState::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aUnlockState.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aViewedState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aViewedState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aViewedState[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aViewedState.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastUnlockedTechnique") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STechniqueUnlockState") << ",\"$val\":";
	STechniqueUnlockState::WriteJson(&s_Object->m_LastUnlockedTechnique, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void STechniquesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STechniquesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iTechniqueUnlockedLevel") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_iTechniqueUnlockedLevel.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_iTechniqueUnlockedLevel[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_iTechniqueUnlockedLevel.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aUnlockState") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aUnlockState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aUnlockState[i];
		STechniqueUnlockState::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aUnlockState.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aViewedState") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aViewedState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aViewedState[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aViewedState.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastUnlockedTechnique") << ":";
	STechniqueUnlockState::WriteSimpleJson(&s_Object->m_LastUnlockedTechnique, p_Stream);

	p_Stream << "}";
}

void STechniquesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STechniquesSaveData s_Object {};

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_iTechniqueUnlockedLevel"])
	{
		s_Object.m_iTechniqueUnlockedLevel[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aUnlockState"];
	s_Object.m_aUnlockState.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STechniqueUnlockState s_ArrayItem0;
		STechniqueUnlockState::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aUnlockState[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aViewedState"];
	s_Object.m_aViewedState.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aViewedState[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	{
		STechniqueUnlockState s_Item {};
		STechniqueUnlockState::FromSimpleJson(p_Document["m_LastUnlockedTechnique"], &s_Item);
		s_Object.m_LastUnlockedTechnique = s_Item;
	}

	*reinterpret_cast<STechniquesSaveData*>(p_Target) = s_Object;
}

void STechniquesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STechniquesSaveData*>(p_Object);

	TFixedArray<uint8, 10>::Serialize(&s_Object->m_iTechniqueUnlockedLevel, p_Serializer, p_OwnOffset + offsetof(STechniquesSaveData, m_iTechniqueUnlockedLevel));
	TArray<STechniqueUnlockState>::Serialize(&s_Object->m_aUnlockState, p_Serializer, p_OwnOffset + offsetof(STechniquesSaveData, m_aUnlockState));
	TArray<bool>::Serialize(&s_Object->m_aViewedState, p_Serializer, p_OwnOffset + offsetof(STechniquesSaveData, m_aViewedState));
	STechniqueUnlockState::Serialize(&s_Object->m_LastUnlockedTechnique, p_Serializer, p_OwnOffset + offsetof(STechniquesSaveData, m_LastUnlockedTechnique));
}

bool STechniquesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STechniquesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STechniquesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STechniquesSaveData::operator==(const STechniquesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STechniquesSaveData>)
		return false;

	if (m_iTechniqueUnlockedLevel != p_Other.m_iTechniqueUnlockedLevel) return false;
	if (m_aUnlockState != p_Other.m_aUnlockState) return false;
	if (m_aViewedState != p_Other.m_aViewedState) return false;
	if (m_LastUnlockedTechnique != p_Other.m_LastUnlockedTechnique) return false;

	return true;
}

ZHMTypeInfo STemplateSubEntity::TypeInfo = ZHMTypeInfo("STemplateSubEntity", sizeof(STemplateSubEntity), alignof(STemplateSubEntity), STemplateSubEntity::WriteJson, STemplateSubEntity::WriteSimpleJson, STemplateSubEntity::FromSimpleJson, STemplateSubEntity::Serialize, STemplateSubEntity::Equals);

void STemplateSubEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("parentIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->parentIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplateProperty>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateProperty") << ",\"$val\":";
		SEntityTemplateProperty::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("postInitPropertyValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplateProperty>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->postInitPropertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->postInitPropertyValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateProperty") << ",\"$val\":";
		SEntityTemplateProperty::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->postInitPropertyValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STemplateSubEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("parentIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->parentIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("postInitPropertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->postInitPropertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->postInitPropertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->postInitPropertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateSubEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateSubEntity s_Object {};

	s_Object.parentIndex = simdjson::from_json_int32(p_Document["parentIndex"]);

	s_Object.entityTypeResourceIndex = simdjson::from_json_int32(p_Document["entityTypeResourceIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyValues"];
	s_Object.propertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyValues[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["postInitPropertyValues"];
	s_Object.postInitPropertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.postInitPropertyValues[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STemplateSubEntity*>(p_Target) = s_Object;
}

void STemplateSubEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntity*>(p_Object);

	TArray<SEntityTemplateProperty>::Serialize(&s_Object->propertyValues, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntity, propertyValues));
	TArray<SEntityTemplateProperty>::Serialize(&s_Object->postInitPropertyValues, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntity, postInitPropertyValues));
}

bool STemplateSubEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateSubEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateSubEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateSubEntity::operator==(const STemplateSubEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateSubEntity>)
		return false;

	if (parentIndex != p_Other.parentIndex) return false;
	if (entityTypeResourceIndex != p_Other.entityTypeResourceIndex) return false;
	if (propertyValues != p_Other.propertyValues) return false;
	if (postInitPropertyValues != p_Other.postInitPropertyValues) return false;

	return true;
}

ZHMTypeInfo STemplateEntity::TypeInfo = ZHMTypeInfo("STemplateEntity", sizeof(STemplateEntity), alignof(STemplateEntity), STemplateEntity::WriteJson, STemplateEntity::WriteSimpleJson, STemplateEntity::FromSimpleJson, STemplateEntity::Serialize, STemplateEntity::Equals);

void STemplateEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STemplateSubEntity>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STemplateSubEntity") << ",\"$val\":";
		STemplateSubEntity::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STemplateEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		STemplateSubEntity::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateEntity s_Object {};

	s_Object.blueprintIndexInResourceHeader = simdjson::from_json_int32(p_Document["blueprintIndexInResourceHeader"]);

	s_Object.rootEntityIndex = simdjson::from_json_int32(p_Document["rootEntityIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["entityTemplates"];
	s_Object.entityTemplates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STemplateSubEntity s_ArrayItem0;
		STemplateSubEntity::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.entityTemplates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STemplateEntity*>(p_Target) = s_Object;
}

void STemplateEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateEntity*>(p_Object);

	TArray<STemplateSubEntity>::Serialize(&s_Object->entityTemplates, p_Serializer, p_OwnOffset + offsetof(STemplateEntity, entityTemplates));
}

bool STemplateEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateEntity::operator==(const STemplateEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateEntity>)
		return false;

	if (blueprintIndexInResourceHeader != p_Other.blueprintIndexInResourceHeader) return false;
	if (rootEntityIndex != p_Other.rootEntityIndex) return false;
	if (entityTemplates != p_Other.entityTemplates) return false;

	return true;
}

ZHMTypeInfo STemplateSubEntityBlueprint::TypeInfo = ZHMTypeInfo("STemplateSubEntityBlueprint", sizeof(STemplateSubEntityBlueprint), alignof(STemplateSubEntityBlueprint), STemplateSubEntityBlueprint::WriteJson, STemplateSubEntityBlueprint::WriteSimpleJson, STemplateSubEntityBlueprint::FromSimpleJson, STemplateSubEntityBlueprint::Serialize, STemplateSubEntityBlueprint::Equals);

void STemplateSubEntityBlueprint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("parentIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->parentIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyAliases") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplatePropertyAlias>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyAliases.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyAliases[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplatePropertyAlias") << ",\"$val\":";
		SEntityTemplatePropertyAlias::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->propertyAliases.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TPair<ZString,SEntityTemplateReference>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TPair<ZString,SEntityTemplateReference>") << ",\"$val\":";
		TPair<ZString,SEntityTemplateReference>::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->exposedEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedInterfaces") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TPair<ZString,int32>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedInterfaces.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedInterfaces[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TPair<ZString,int32>") << ",\"$val\":";
		TPair<ZString,int32>::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->exposedInterfaces.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entitySubsets") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TPair<ZString,SEntityTemplateEntitySubset>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entitySubsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->entitySubsets[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TPair<ZString,SEntityTemplateEntitySubset>") << ",\"$val\":";
		TPair<ZString,SEntityTemplateEntitySubset>::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->entitySubsets.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STemplateSubEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("parentIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->parentIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyAliases") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyAliases.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyAliases[i];
		SEntityTemplatePropertyAlias::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyAliases.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedEntities[i];
		TPair<ZString,SEntityTemplateReference>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->exposedEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedInterfaces") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedInterfaces.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedInterfaces[i];
		TPair<ZString,int32>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->exposedInterfaces.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entitySubsets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entitySubsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->entitySubsets[i];
		TPair<ZString,SEntityTemplateEntitySubset>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entitySubsets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateSubEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateSubEntityBlueprint s_Object {};

	s_Object.parentIndex = simdjson::from_json_int32(p_Document["parentIndex"]);

	s_Object.entityTypeResourceIndex = simdjson::from_json_int32(p_Document["entityTypeResourceIndex"]);

	s_Object.entityName = std::string_view(p_Document["entityName"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyAliases"];
	s_Object.propertyAliases.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePropertyAlias s_ArrayItem0;
		SEntityTemplatePropertyAlias::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyAliases[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["exposedEntities"];
	s_Object.exposedEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TPair<ZString,SEntityTemplateReference> s_ArrayItem0;
		TPair<ZString,SEntityTemplateReference>::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.exposedEntities[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["exposedInterfaces"];
	s_Object.exposedInterfaces.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TPair<ZString,int32> s_ArrayItem0;
		TPair<ZString,int32>::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.exposedInterfaces[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["entitySubsets"];
	s_Object.entitySubsets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TPair<ZString,SEntityTemplateEntitySubset> s_ArrayItem0;
		TPair<ZString,SEntityTemplateEntitySubset>::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.entitySubsets[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STemplateSubEntityBlueprint*>(p_Target) = s_Object;
}

void STemplateSubEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Object);

	ZString::Serialize(&s_Object->entityName, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, entityName));
	TArray<SEntityTemplatePropertyAlias>::Serialize(&s_Object->propertyAliases, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, propertyAliases));
	TArray<TPair<ZString,SEntityTemplateReference>>::Serialize(&s_Object->exposedEntities, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, exposedEntities));
	TArray<TPair<ZString,int32>>::Serialize(&s_Object->exposedInterfaces, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, exposedInterfaces));
	TArray<TPair<ZString,SEntityTemplateEntitySubset>>::Serialize(&s_Object->entitySubsets, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, entitySubsets));
}

bool STemplateSubEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateSubEntityBlueprint::operator==(const STemplateSubEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateSubEntityBlueprint>)
		return false;

	if (parentIndex != p_Other.parentIndex) return false;
	if (entityTypeResourceIndex != p_Other.entityTypeResourceIndex) return false;
	if (entityName != p_Other.entityName) return false;
	if (propertyAliases != p_Other.propertyAliases) return false;
	if (exposedEntities != p_Other.exposedEntities) return false;
	if (exposedInterfaces != p_Other.exposedInterfaces) return false;
	if (entitySubsets != p_Other.entitySubsets) return false;

	return true;
}

ZHMTypeInfo STemplateEntityBlueprint::TypeInfo = ZHMTypeInfo("STemplateEntityBlueprint", sizeof(STemplateEntityBlueprint), alignof(STemplateEntityBlueprint), STemplateEntityBlueprint::WriteJson, STemplateEntityBlueprint::WriteSimpleJson, STemplateEntityBlueprint::FromSimpleJson, STemplateEntityBlueprint::Serialize, STemplateEntityBlueprint::Equals);

void STemplateEntityBlueprint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STemplateSubEntityBlueprint>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STemplateSubEntityBlueprint") << ",\"$val\":";
		STemplateSubEntityBlueprint::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("pinConnections") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplatePinConnection>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pinConnections.size(); ++i)
	{
		auto& s_Item0 = s_Object->pinConnections[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplatePinConnection") << ",\"$val\":";
		SEntityTemplatePinConnection::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->pinConnections.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inputPinForwardings") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplatePinConnection>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->inputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->inputPinForwardings[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplatePinConnection") << ",\"$val\":";
		SEntityTemplatePinConnection::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->inputPinForwardings.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("outputPinForwardings") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplatePinConnection>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->outputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->outputPinForwardings[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplatePinConnection") << ",\"$val\":";
		SEntityTemplatePinConnection::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->outputPinForwardings.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STemplateEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		STemplateSubEntityBlueprint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("pinConnections") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pinConnections.size(); ++i)
	{
		auto& s_Item0 = s_Object->pinConnections[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->pinConnections.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inputPinForwardings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->inputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->inputPinForwardings[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->inputPinForwardings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("outputPinForwardings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->outputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->outputPinForwardings[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->outputPinForwardings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateEntityBlueprint s_Object {};

	s_Object.rootEntityIndex = simdjson::from_json_int32(p_Document["rootEntityIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["entityTemplates"];
	s_Object.entityTemplates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STemplateSubEntityBlueprint s_ArrayItem0;
		STemplateSubEntityBlueprint::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.entityTemplates[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["pinConnections"];
	s_Object.pinConnections.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePinConnection s_ArrayItem0;
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.pinConnections[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["inputPinForwardings"];
	s_Object.inputPinForwardings.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePinConnection s_ArrayItem0;
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.inputPinForwardings[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["outputPinForwardings"];
	s_Object.outputPinForwardings.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePinConnection s_ArrayItem0;
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.outputPinForwardings[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STemplateEntityBlueprint*>(p_Target) = s_Object;
}

void STemplateEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	TArray<STemplateSubEntityBlueprint>::Serialize(&s_Object->entityTemplates, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, entityTemplates));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->pinConnections, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, pinConnections));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->inputPinForwardings, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, inputPinForwardings));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->outputPinForwardings, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, outputPinForwardings));
}

bool STemplateEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateEntityBlueprint::operator==(const STemplateEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateEntityBlueprint>)
		return false;

	if (rootEntityIndex != p_Other.rootEntityIndex) return false;
	if (entityTemplates != p_Other.entityTemplates) return false;
	if (pinConnections != p_Other.pinConnections) return false;
	if (inputPinForwardings != p_Other.inputPinForwardings) return false;
	if (outputPinForwardings != p_Other.outputPinForwardings) return false;

	return true;
}

ZHMTypeInfo STestMiniStruct::TypeInfo = ZHMTypeInfo("STestMiniStruct", sizeof(STestMiniStruct), alignof(STestMiniStruct), STestMiniStruct::WriteJson, STestMiniStruct::WriteSimpleJson, STestMiniStruct::FromSimpleJson, STestMiniStruct::Serialize, STestMiniStruct::Equals);

void STestMiniStruct::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestMiniStruct*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iIntValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iIntValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFloatValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFloatValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);
	p_Stream << "}";

	p_Stream << "}";
}

void STestMiniStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestMiniStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iIntValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iIntValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFloatValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFloatValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);

	p_Stream << "}";
}

void STestMiniStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STestMiniStruct s_Object {};

	s_Object.m_iIntValue = simdjson::from_json_int32(p_Document["m_iIntValue"]);

	s_Object.m_fFloatValue = simdjson::from_json_float32(p_Document["m_fFloatValue"]);

	s_Object.m_sText = std::string_view(p_Document["m_sText"]);

	*reinterpret_cast<STestMiniStruct*>(p_Target) = s_Object;
}

void STestMiniStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestMiniStruct*>(p_Object);

	ZString::Serialize(&s_Object->m_sText, p_Serializer, p_OwnOffset + offsetof(STestMiniStruct, m_sText));
}

bool STestMiniStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestMiniStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<STestMiniStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestMiniStruct::operator==(const STestMiniStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestMiniStruct>)
		return false;

	if (m_iIntValue != p_Other.m_iIntValue) return false;
	if (m_fFloatValue != p_Other.m_fFloatValue) return false;
	if (m_sText != p_Other.m_sText) return false;

	return true;
}

ZHMTypeInfo STestStructure::TypeInfo = ZHMTypeInfo("STestStructure", sizeof(STestStructure), alignof(STestStructure), STestStructure::WriteJson, STestStructure::WriteSimpleJson, STestStructure::FromSimpleJson, STestStructure::Serialize, STestStructure::Equals);

void STestStructure::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStructure*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fWidth") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWidth);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHeight") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeight);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Mini") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STestMiniStruct") << ",\"$val\":";
	STestMiniStruct::WriteJson(&s_Object->m_Mini, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void STestStructure::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStructure*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWidth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Mini") << ":";
	STestMiniStruct::WriteSimpleJson(&s_Object->m_Mini, p_Stream);

	p_Stream << "}";
}

void STestStructure::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STestStructure s_Object {};

	s_Object.m_fWidth = simdjson::from_json_float32(p_Document["m_fWidth"]);

	s_Object.m_fHeight = simdjson::from_json_float32(p_Document["m_fHeight"]);

	s_Object.m_fAngle = simdjson::from_json_float32(p_Document["m_fAngle"]);

	s_Object.m_sDescription = std::string_view(p_Document["m_sDescription"]);

	{
		STestMiniStruct s_Item {};
		STestMiniStruct::FromSimpleJson(p_Document["m_Mini"], &s_Item);
		s_Object.m_Mini = s_Item;
	}

	*reinterpret_cast<STestStructure*>(p_Target) = s_Object;
}

void STestStructure::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestStructure*>(p_Object);

	ZString::Serialize(&s_Object->m_sDescription, p_Serializer, p_OwnOffset + offsetof(STestStructure, m_sDescription));
	STestMiniStruct::Serialize(&s_Object->m_Mini, p_Serializer, p_OwnOffset + offsetof(STestStructure, m_Mini));
}

bool STestStructure::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestStructure*>(p_Left);
	auto* s_Right = reinterpret_cast<STestStructure*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestStructure::operator==(const STestStructure& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestStructure>)
		return false;

	if (m_fWidth != p_Other.m_fWidth) return false;
	if (m_fHeight != p_Other.m_fHeight) return false;
	if (m_fAngle != p_Other.m_fAngle) return false;
	if (m_sDescription != p_Other.m_sDescription) return false;
	if (m_Mini != p_Other.m_Mini) return false;

	return true;
}

ZHMTypeInfo SUIOptionValue::TypeInfo = ZHMTypeInfo("SUIOptionValue", sizeof(SUIOptionValue), alignof(SUIOptionValue), SUIOptionValue::WriteJson, SUIOptionValue::WriteSimpleJson, SUIOptionValue::FromSimpleJson, SUIOptionValue::Serialize, SUIOptionValue::Equals);

void SUIOptionValue::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOptionValue*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("key") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->key);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->intValue);
	p_Stream << "}";

	p_Stream << "}";
}

void SUIOptionValue::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOptionValue*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("key") << ":";
	p_Stream << simdjson::as_json_string(s_Object->key);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->intValue);

	p_Stream << "}";
}

void SUIOptionValue::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUIOptionValue s_Object {};

	s_Object.key = simdjson::from_json_uint32(p_Document["key"]);

	s_Object.type = simdjson::from_json_uint8(p_Document["type"]);

	s_Object.intValue = simdjson::from_json_int32(p_Document["intValue"]);

	*reinterpret_cast<SUIOptionValue*>(p_Target) = s_Object;
}

void SUIOptionValue::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIOptionValue*>(p_Object);

}

bool SUIOptionValue::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIOptionValue*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIOptionValue*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIOptionValue::operator==(const SUIOptionValue& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIOptionValue>)
		return false;

	if (key != p_Other.key) return false;
	if (type != p_Other.type) return false;
	if (intValue != p_Other.intValue) return false;

	return true;
}

ZHMTypeInfo SUIOptionsData::TypeInfo = ZHMTypeInfo("SUIOptionsData", sizeof(SUIOptionsData), alignof(SUIOptionsData), SUIOptionsData::WriteJson, SUIOptionsData::WriteSimpleJson, SUIOptionsData::FromSimpleJson, SUIOptionsData::Serialize, SUIOptionsData::Equals);

void SUIOptionsData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOptionsData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("data") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SUIOptionValue>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->data.size(); ++i)
	{
		auto& s_Item0 = s_Object->data[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SUIOptionValue") << ",\"$val\":";
		SUIOptionValue::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->data.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SUIOptionsData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOptionsData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("data") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->data.size(); ++i)
	{
		auto& s_Item0 = s_Object->data[i];
		SUIOptionValue::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->data.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUIOptionsData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUIOptionsData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["data"];
	s_Object.data.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SUIOptionValue s_ArrayItem0;
		SUIOptionValue::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.data[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SUIOptionsData*>(p_Target) = s_Object;
}

void SUIOptionsData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIOptionsData*>(p_Object);

	TArray<SUIOptionValue>::Serialize(&s_Object->data, p_Serializer, p_OwnOffset + offsetof(SUIOptionsData, data));
}

bool SUIOptionsData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIOptionsData*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIOptionsData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIOptionsData::operator==(const SUIOptionsData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIOptionsData>)
		return false;

	if (data != p_Other.data) return false;

	return true;
}

ZHMTypeInfo SVector2::TypeInfo = ZHMTypeInfo("SVector2", sizeof(SVector2), alignof(SVector2), SVector2::WriteJson, SVector2::WriteSimpleJson, SVector2::FromSimpleJson, SVector2::Serialize, SVector2::Equals);

void SVector2::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << "}";

	p_Stream << "}";
}

void SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);

	p_Stream << "}";
}

void SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVector2 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	*reinterpret_cast<SVector2*>(p_Target) = s_Object;
}

void SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

}

bool SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector2::operator==(const SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector2>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;

	return true;
}

ZHMTypeInfo SWeaponSoundDefs::TypeInfo = ZHMTypeInfo("SWeaponSoundDefs", sizeof(SWeaponSoundDefs), alignof(SWeaponSoundDefs), SWeaponSoundDefs::WriteJson, SWeaponSoundDefs::WriteSimpleJson, SWeaponSoundDefs::FromSimpleJson, SWeaponSoundDefs::Serialize, SWeaponSoundDefs::Equals);

void SWeaponSoundDefs::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SWeaponSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SWeaponSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWeaponSoundDefs s_Object {};

	*reinterpret_cast<SWeaponSoundDefs*>(p_Target) = s_Object;
}

void SWeaponSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Object);

}

bool SWeaponSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWeaponSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SWeaponSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWeaponSoundDefs::operator==(const SWeaponSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWeaponSoundDefs>)
		return false;


	return true;
}

ZHMTypeInfo ZCloseCombatDef_SActorNoise::TypeInfo = ZHMTypeInfo("ZCloseCombatDef.SActorNoise", sizeof(ZCloseCombatDef_SActorNoise), alignof(ZCloseCombatDef_SActorNoise), ZCloseCombatDef_SActorNoise::WriteJson, ZCloseCombatDef_SActorNoise::WriteSimpleJson, ZCloseCombatDef_SActorNoise::FromSimpleJson, ZCloseCombatDef_SActorNoise::Serialize, ZCloseCombatDef_SActorNoise::Equals);

void ZCloseCombatDef_SActorNoise::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iSpeak") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorSoundDefs.EDefinition") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_iSpeak)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_iSpeak))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAIEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAIEventType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAIEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eAIEvent))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAIEventDistance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAIEventDistance);
	p_Stream << "}";

	p_Stream << "}";
}

void ZCloseCombatDef_SActorNoise::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iSpeak") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_iSpeak)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAIEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eAIEvent)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAIEventDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAIEventDistance);

	p_Stream << "}";
}

void ZCloseCombatDef_SActorNoise::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZCloseCombatDef_SActorNoise s_Object {};

	s_Object.m_iSpeak = static_cast<SActorSoundDefs_EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["m_iSpeak"])));

	s_Object.m_eAIEvent = static_cast<EAIEventType>(ZHMEnums::GetEnumValueByName("EAIEventType", std::string_view(p_Document["m_eAIEvent"])));

	s_Object.m_fAIEventDistance = simdjson::from_json_float32(p_Document["m_fAIEventDistance"]);

	*reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Target) = s_Object;
}

void ZCloseCombatDef_SActorNoise::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Object);

}

bool ZCloseCombatDef_SActorNoise::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCloseCombatDef_SActorNoise::operator==(const ZCloseCombatDef_SActorNoise& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCloseCombatDef_SActorNoise>)
		return false;

	if (m_iSpeak != p_Other.m_iSpeak) return false;
	if (m_eAIEvent != p_Other.m_eAIEvent) return false;
	if (m_fAIEventDistance != p_Other.m_fAIEventDistance) return false;

	return true;
}

ZHMTypeInfo ZComponentCreator::TypeInfo = ZHMTypeInfo("ZComponentCreator", sizeof(ZComponentCreator), alignof(ZComponentCreator), ZComponentCreator::WriteJson, ZComponentCreator::WriteSimpleJson, ZComponentCreator::FromSimpleJson, ZComponentCreator::Serialize, ZComponentCreator::Equals);

void ZComponentCreator::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sComponentName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sComponentName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aArgs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZVariant>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aArgs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aArgs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
		ZVariant::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aArgs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZComponentCreator::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sComponentName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sComponentName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aArgs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aArgs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aArgs[i];
		ZVariant::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aArgs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZComponentCreator::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZComponentCreator s_Object {};

	s_Object.m_sComponentName = std::string_view(p_Document["m_sComponentName"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aArgs"];
	s_Object.m_aArgs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZVariant s_ArrayItem0;
		ZVariant::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aArgs[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZComponentCreator*>(p_Target) = s_Object;
}

void ZComponentCreator::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	ZString::Serialize(&s_Object->m_sComponentName, p_Serializer, p_OwnOffset + offsetof(ZComponentCreator, m_sComponentName));
	TArray<ZVariant>::Serialize(&s_Object->m_aArgs, p_Serializer, p_OwnOffset + offsetof(ZComponentCreator, m_aArgs));
}

bool ZComponentCreator::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZComponentCreator*>(p_Left);
	auto* s_Right = reinterpret_cast<ZComponentCreator*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZComponentCreator::operator==(const ZComponentCreator& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZComponentCreator>)
		return false;

	if (m_sComponentName != p_Other.m_sComponentName) return false;
	if (m_aArgs != p_Other.m_aArgs) return false;

	return true;
}

ZHMTypeInfo ZCurve::TypeInfo = ZHMTypeInfo("ZCurve", sizeof(ZCurve), alignof(ZCurve), ZCurve::WriteJson, ZCurve::WriteSimpleJson, ZCurve::FromSimpleJson, ZCurve::Serialize, ZCurve::Equals);

void ZCurve::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("data") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TFixedArray<float32>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->data.size(); ++i)
	{
		auto& s_Item0 = s_Object->data[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TFixedArray<float32>") << ",\"$val\":";
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
			p_Stream << simdjson::as_json_string(s_Item1);
			p_Stream << "}";

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}
		p_Stream << "]";
		p_Stream << "}";

		if (i < s_Object->data.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZCurve::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("data") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->data.size(); ++i)
	{
		auto& s_Item0 = s_Object->data[i];
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << simdjson::as_json_string(s_Item1);

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}

		p_Stream << "]";

		if (i < s_Object->data.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZCurve::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZCurve s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["data"];
	s_Object.data.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TFixedArray<float32, 8> s_ArrayItem0;
		{
		size_t s_Index1 = 0;
		for (simdjson::ondemand::value s_Item1 : s_Item0)
		{
			s_ArrayItem0[s_Index1] = simdjson::from_json_float32(s_Item1);
			++s_Index1;
		}
		}
		s_Object.data[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZCurve*>(p_Target) = s_Object;
}

void ZCurve::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	TArray<TFixedArray<float32, 8>>::Serialize(&s_Object->data, p_Serializer, p_OwnOffset + offsetof(ZCurve, data));
}

bool ZCurve::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCurve*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCurve*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCurve::operator==(const ZCurve& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCurve>)
		return false;

	if (data != p_Other.data) return false;

	return true;
}

ZHMTypeInfo ZEntityID::TypeInfo = ZHMTypeInfo("ZEntityID", sizeof(ZEntityID), alignof(ZEntityID), ZEntityID::WriteJson, ZEntityID::WriteSimpleJson, ZEntityID::FromSimpleJson, ZEntityID::Serialize, ZEntityID::Equals);

void ZEntityID::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sStr") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sStr);
	p_Stream << "}";

	p_Stream << "}";
}

void ZEntityID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sStr") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sStr);

	p_Stream << "}";
}

void ZEntityID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityID s_Object {};

	s_Object.m_sStr = std::string_view(p_Document["m_sStr"]);

	*reinterpret_cast<ZEntityID*>(p_Target) = s_Object;
}

void ZEntityID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	ZString::Serialize(&s_Object->m_sStr, p_Serializer, p_OwnOffset + offsetof(ZEntityID, m_sStr));
}

bool ZEntityID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityID::operator==(const ZEntityID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityID>)
		return false;

	if (m_sStr != p_Other.m_sStr) return false;

	return true;
}

ZHMTypeInfo ZEntityRef::TypeInfo = ZHMTypeInfo("ZEntityRef", sizeof(ZEntityRef), alignof(ZEntityRef), ZEntityRef::WriteJson, ZEntityRef::WriteSimpleJson, ZEntityRef::FromSimpleJson, ZEntityRef::Serialize, ZEntityRef::Equals);

void ZEntityRef::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZEntityRef::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZEntityRef::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityRef s_Object {};

	*reinterpret_cast<ZEntityRef*>(p_Target) = s_Object;
}

void ZEntityRef::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

}

bool ZEntityRef::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityRef*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityRef*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityRef::operator==(const ZEntityRef& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityRef>)
		return false;


	return true;
}

ZHMTypeInfo ZEntityReference::TypeInfo = ZHMTypeInfo("ZEntityReference", sizeof(ZEntityReference), alignof(ZEntityReference), ZEntityReference::WriteJson, ZEntityReference::WriteSimpleJson, ZEntityReference::FromSimpleJson, ZEntityReference::Serialize, ZEntityReference::Equals);

void ZEntityReference::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_EntityID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZEntityID") << ",\"$val\":";
	ZEntityID::WriteJson(&s_Object->m_EntityID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);
	p_Stream << "}";

	p_Stream << "}";
}

void ZEntityReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_EntityID") << ":";
	ZEntityID::WriteSimpleJson(&s_Object->m_EntityID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);

	p_Stream << "}";
}

void ZEntityReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityReference s_Object {};

	{
		ZEntityID s_Item {};
		ZEntityID::FromSimpleJson(p_Document["m_EntityID"], &s_Item);
		s_Object.m_EntityID = s_Item;
	}

	s_Object.m_sExposedEntity = std::string_view(p_Document["m_sExposedEntity"]);

	*reinterpret_cast<ZEntityReference*>(p_Target) = s_Object;
}

void ZEntityReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	ZEntityID::Serialize(&s_Object->m_EntityID, p_Serializer, p_OwnOffset + offsetof(ZEntityReference, m_EntityID));
	ZString::Serialize(&s_Object->m_sExposedEntity, p_Serializer, p_OwnOffset + offsetof(ZEntityReference, m_sExposedEntity));
}

bool ZEntityReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityReference*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityReference::operator==(const ZEntityReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityReference>)
		return false;

	if (m_EntityID != p_Other.m_EntityID) return false;
	if (m_sExposedEntity != p_Other.m_sExposedEntity) return false;

	return true;
}

ZHMTypeInfo ZGameTime::TypeInfo = ZHMTypeInfo("ZGameTime", sizeof(ZGameTime), alignof(ZGameTime), ZGameTime::WriteJson, ZGameTime::WriteSimpleJson, ZGameTime::FromSimpleJson, ZGameTime::Serialize, ZGameTime::Equals);

void ZGameTime::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nTicks") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTicks);
	p_Stream << "}";

	p_Stream << "}";
}

void ZGameTime::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nTicks") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTicks);

	p_Stream << "}";
}

void ZGameTime::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGameTime s_Object {};

	s_Object.m_nTicks = simdjson::from_json_int64(p_Document["m_nTicks"]);

	*reinterpret_cast<ZGameTime*>(p_Target) = s_Object;
}

void ZGameTime::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

}

bool ZGameTime::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGameTime*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGameTime*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGameTime::operator==(const ZGameTime& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGameTime>)
		return false;

	if (m_nTicks != p_Other.m_nTicks) return false;

	return true;
}

ZHMTypeInfo ZHitmanMorphemePostProcessorFiberWireCallback::TypeInfo = ZHMTypeInfo("ZHitmanMorphemePostProcessorFiberWireCallback", sizeof(ZHitmanMorphemePostProcessorFiberWireCallback), alignof(ZHitmanMorphemePostProcessorFiberWireCallback), ZHitmanMorphemePostProcessorFiberWireCallback::WriteJson, ZHitmanMorphemePostProcessorFiberWireCallback::WriteSimpleJson, ZHitmanMorphemePostProcessorFiberWireCallback::FromSimpleJson, ZHitmanMorphemePostProcessorFiberWireCallback::Serialize, ZHitmanMorphemePostProcessorFiberWireCallback::Equals);

void ZHitmanMorphemePostProcessorFiberWireCallback::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHitmanMorphemePostProcessorFiberWireCallback*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZHitmanMorphemePostProcessorFiberWireCallback::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHitmanMorphemePostProcessorFiberWireCallback*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZHitmanMorphemePostProcessorFiberWireCallback::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHitmanMorphemePostProcessorFiberWireCallback s_Object {};

	*reinterpret_cast<ZHitmanMorphemePostProcessorFiberWireCallback*>(p_Target) = s_Object;
}

void ZHitmanMorphemePostProcessorFiberWireCallback::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHitmanMorphemePostProcessorFiberWireCallback*>(p_Object);

}

bool ZHitmanMorphemePostProcessorFiberWireCallback::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHitmanMorphemePostProcessorFiberWireCallback*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHitmanMorphemePostProcessorFiberWireCallback*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHitmanMorphemePostProcessorFiberWireCallback::operator==(const ZHitmanMorphemePostProcessorFiberWireCallback& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHitmanMorphemePostProcessorFiberWireCallback>)
		return false;


	return true;
}

ZHMTypeInfo ZHitmanMorphemePostProcessorLedgeHangCallback::TypeInfo = ZHMTypeInfo("ZHitmanMorphemePostProcessorLedgeHangCallback", sizeof(ZHitmanMorphemePostProcessorLedgeHangCallback), alignof(ZHitmanMorphemePostProcessorLedgeHangCallback), ZHitmanMorphemePostProcessorLedgeHangCallback::WriteJson, ZHitmanMorphemePostProcessorLedgeHangCallback::WriteSimpleJson, ZHitmanMorphemePostProcessorLedgeHangCallback::FromSimpleJson, ZHitmanMorphemePostProcessorLedgeHangCallback::Serialize, ZHitmanMorphemePostProcessorLedgeHangCallback::Equals);

void ZHitmanMorphemePostProcessorLedgeHangCallback::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHitmanMorphemePostProcessorLedgeHangCallback*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZHitmanMorphemePostProcessorLedgeHangCallback::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHitmanMorphemePostProcessorLedgeHangCallback*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZHitmanMorphemePostProcessorLedgeHangCallback::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHitmanMorphemePostProcessorLedgeHangCallback s_Object {};

	*reinterpret_cast<ZHitmanMorphemePostProcessorLedgeHangCallback*>(p_Target) = s_Object;
}

void ZHitmanMorphemePostProcessorLedgeHangCallback::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHitmanMorphemePostProcessorLedgeHangCallback*>(p_Object);

}

bool ZHitmanMorphemePostProcessorLedgeHangCallback::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHitmanMorphemePostProcessorLedgeHangCallback*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHitmanMorphemePostProcessorLedgeHangCallback*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHitmanMorphemePostProcessorLedgeHangCallback::operator==(const ZHitmanMorphemePostProcessorLedgeHangCallback& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHitmanMorphemePostProcessorLedgeHangCallback>)
		return false;


	return true;
}

ZHMTypeInfo ZInventorySlot::TypeInfo = ZHMTypeInfo("ZInventorySlot", sizeof(ZInventorySlot), alignof(ZInventorySlot), ZInventorySlot::WriteJson, ZInventorySlot::WriteSimpleJson, ZInventorySlot::FromSimpleJson, ZInventorySlot::Serialize, ZInventorySlot::Equals);

void ZInventorySlot::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInventorySlot*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZInventorySlot::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInventorySlot*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZInventorySlot::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInventorySlot s_Object {};

	*reinterpret_cast<ZInventorySlot*>(p_Target) = s_Object;
}

void ZInventorySlot::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInventorySlot*>(p_Object);

}

bool ZInventorySlot::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInventorySlot*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInventorySlot*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInventorySlot::operator==(const ZInventorySlot& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInventorySlot>)
		return false;


	return true;
}

ZHMTypeInfo ZPostfilterGraphBaseNode::TypeInfo = ZHMTypeInfo("ZPostfilterGraphBaseNode", sizeof(ZPostfilterGraphBaseNode), alignof(ZPostfilterGraphBaseNode), ZPostfilterGraphBaseNode::WriteJson, ZPostfilterGraphBaseNode::WriteSimpleJson, ZPostfilterGraphBaseNode::FromSimpleJson, ZPostfilterGraphBaseNode::Serialize, ZPostfilterGraphBaseNode::Equals);

void ZPostfilterGraphBaseNode::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZPostfilterGraphBaseNode::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZPostfilterGraphBaseNode::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZPostfilterGraphBaseNode s_Object {};

	*reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Target) = s_Object;
}

void ZPostfilterGraphBaseNode::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

}

bool ZPostfilterGraphBaseNode::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPostfilterGraphBaseNode::operator==(const ZPostfilterGraphBaseNode& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPostfilterGraphBaseNode>)
		return false;


	return true;
}

ZHMTypeInfo ZPresenceState::TypeInfo = ZHMTypeInfo("ZPresenceState", sizeof(ZPresenceState), alignof(ZPresenceState), ZPresenceState::WriteJson, ZPresenceState::WriteSimpleJson, ZPresenceState::FromSimpleJson, ZPresenceState::Serialize, ZPresenceState::Equals);

void ZPresenceState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPresenceState*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZPresenceState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPresenceState*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZPresenceState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZPresenceState s_Object {};

	*reinterpret_cast<ZPresenceState*>(p_Target) = s_Object;
}

void ZPresenceState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPresenceState*>(p_Object);

}

bool ZPresenceState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPresenceState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPresenceState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPresenceState::operator==(const ZPresenceState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPresenceState>)
		return false;


	return true;
}

ZHMTypeInfo ZRayQueryInput::TypeInfo = ZHMTypeInfo("ZRayQueryInput", sizeof(ZRayQueryInput), alignof(ZRayQueryInput), ZRayQueryInput::WriteJson, ZRayQueryInput::WriteSimpleJson, ZRayQueryInput::FromSimpleJson, ZRayQueryInput::Serialize, ZRayQueryInput::Equals);

void ZRayQueryInput::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZRayQueryInput::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZRayQueryInput::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZRayQueryInput s_Object {};

	*reinterpret_cast<ZRayQueryInput*>(p_Target) = s_Object;
}

void ZRayQueryInput::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

}

bool ZRayQueryInput::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRayQueryInput*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRayQueryInput*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRayQueryInput::operator==(const ZRayQueryInput& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRayQueryInput>)
		return false;


	return true;
}

ZHMTypeInfo ZResourcePtr::TypeInfo = ZHMTypeInfo("ZResourcePtr", sizeof(ZResourcePtr), alignof(ZResourcePtr), ZResourcePtr::WriteJson, ZResourcePtr::WriteSimpleJson, ZResourcePtr::FromSimpleJson, ZResourcePtr::Serialize, ZResourcePtr::Equals);

void ZResourcePtr::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZResourcePtr::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZResourcePtr::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZResourcePtr s_Object {};

	*reinterpret_cast<ZResourcePtr*>(p_Target) = s_Object;
}

void ZResourcePtr::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

}

bool ZResourcePtr::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZResourcePtr*>(p_Left);
	auto* s_Right = reinterpret_cast<ZResourcePtr*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZResourcePtr::operator==(const ZResourcePtr& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZResourcePtr>)
		return false;


	return true;
}

ZHMTypeInfo ZRuntimeResourceID::TypeInfo = ZHMTypeInfo("ZRuntimeResourceID", sizeof(ZRuntimeResourceID), alignof(ZRuntimeResourceID), ZRuntimeResourceID::WriteJson, ZRuntimeResourceID::WriteSimpleJson, ZRuntimeResourceID::FromSimpleJson, ZRuntimeResourceID::Serialize, ZRuntimeResourceID::Equals);

void ZRuntimeResourceID::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_IDHigh") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDHigh);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IDLow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDLow);
	p_Stream << "}";

	p_Stream << "}";
}

void ZRuntimeResourceID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_IDHigh") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDHigh);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IDLow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDLow);

	p_Stream << "}";
}

void ZRuntimeResourceID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZRuntimeResourceID s_Object {};

	s_Object.m_IDHigh = simdjson::from_json_uint32(p_Document["m_IDHigh"]);

	s_Object.m_IDLow = simdjson::from_json_uint32(p_Document["m_IDLow"]);

	*reinterpret_cast<ZRuntimeResourceID*>(p_Target) = s_Object;
}

void ZRuntimeResourceID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Serializer.RegisterRuntimeResourceId(p_OwnOffset);
}

bool ZRuntimeResourceID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRuntimeResourceID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRuntimeResourceID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRuntimeResourceID::operator==(const ZRuntimeResourceID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRuntimeResourceID>)
		return false;

	if (m_IDHigh != p_Other.m_IDHigh) return false;
	if (m_IDLow != p_Other.m_IDLow) return false;

	return true;
}

ZHMTypeInfo ZSharedSensorDef_SVisibilitySetting::TypeInfo = ZHMTypeInfo("ZSharedSensorDef.SVisibilitySetting", sizeof(ZSharedSensorDef_SVisibilitySetting), alignof(ZSharedSensorDef_SVisibilitySetting), ZSharedSensorDef_SVisibilitySetting::WriteJson, ZSharedSensorDef_SVisibilitySetting::WriteSimpleJson, ZSharedSensorDef_SVisibilitySetting::FromSimpleJson, ZSharedSensorDef_SVisibilitySetting::Serialize, ZSharedSensorDef_SVisibilitySetting::Equals);

void ZSharedSensorDef_SVisibilitySetting::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eSensitivity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorPerceptionSensitivity") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSensitivity)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorPerceptionSensitivity", static_cast<int>(s_Object->m_eSensitivity))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCloseRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCloseRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralHigh") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralHigh);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralLow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralLow);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeWidthAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeWidthAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeHeightAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeHeightAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeRange);
	p_Stream << "}";

	p_Stream << "}";
}

void ZSharedSensorDef_SVisibilitySetting::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSensitivity") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorPerceptionSensitivity", static_cast<int>(s_Object->m_eSensitivity)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCloseRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCloseRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralHigh") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralHigh);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralLow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralLow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeWidthAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeWidthAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeHeightAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeHeightAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeRange);

	p_Stream << "}";
}

void ZSharedSensorDef_SVisibilitySetting::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSharedSensorDef_SVisibilitySetting s_Object {};

	s_Object.m_eSensitivity = static_cast<EActorPerceptionSensitivity>(ZHMEnums::GetEnumValueByName("EActorPerceptionSensitivity", std::string_view(p_Document["m_eSensitivity"])));

	s_Object.m_fCloseRange = simdjson::from_json_float32(p_Document["m_fCloseRange"]);

	s_Object.m_fPeripheralRange = simdjson::from_json_float32(p_Document["m_fPeripheralRange"]);

	s_Object.m_fPeripheralAngle = simdjson::from_json_float32(p_Document["m_fPeripheralAngle"]);

	s_Object.m_fPeripheralHigh = simdjson::from_json_float32(p_Document["m_fPeripheralHigh"]);

	s_Object.m_fPeripheralLow = simdjson::from_json_float32(p_Document["m_fPeripheralLow"]);

	s_Object.m_fFocusConeWidthAngle = simdjson::from_json_float32(p_Document["m_fFocusConeWidthAngle"]);

	s_Object.m_fFocusConeHeightAngle = simdjson::from_json_float32(p_Document["m_fFocusConeHeightAngle"]);

	s_Object.m_fFocusConeRange = simdjson::from_json_float32(p_Document["m_fFocusConeRange"]);

	*reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Target) = s_Object;
}

void ZSharedSensorDef_SVisibilitySetting::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Object);

}

bool ZSharedSensorDef_SVisibilitySetting::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSharedSensorDef_SVisibilitySetting::operator==(const ZSharedSensorDef_SVisibilitySetting& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSharedSensorDef_SVisibilitySetting>)
		return false;

	if (m_eSensitivity != p_Other.m_eSensitivity) return false;
	if (m_fCloseRange != p_Other.m_fCloseRange) return false;
	if (m_fPeripheralRange != p_Other.m_fPeripheralRange) return false;
	if (m_fPeripheralAngle != p_Other.m_fPeripheralAngle) return false;
	if (m_fPeripheralHigh != p_Other.m_fPeripheralHigh) return false;
	if (m_fPeripheralLow != p_Other.m_fPeripheralLow) return false;
	if (m_fFocusConeWidthAngle != p_Other.m_fFocusConeWidthAngle) return false;
	if (m_fFocusConeHeightAngle != p_Other.m_fFocusConeHeightAngle) return false;
	if (m_fFocusConeRange != p_Other.m_fFocusConeRange) return false;

	return true;
}

ZHMTypeInfo ZSoundBlendCollision::TypeInfo = ZHMTypeInfo("ZSoundBlendCollision", sizeof(ZSoundBlendCollision), alignof(ZSoundBlendCollision), ZSoundBlendCollision::WriteJson, ZSoundBlendCollision::WriteSimpleJson, ZSoundBlendCollision::FromSimpleJson, ZSoundBlendCollision::Serialize, ZSoundBlendCollision::Equals);

void ZSoundBlendCollision::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSoundBlendCollision*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZSoundBlendCollision::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSoundBlendCollision*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSoundBlendCollision::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSoundBlendCollision s_Object {};

	*reinterpret_cast<ZSoundBlendCollision*>(p_Target) = s_Object;
}

void ZSoundBlendCollision::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSoundBlendCollision*>(p_Object);

}

bool ZSoundBlendCollision::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSoundBlendCollision*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSoundBlendCollision*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSoundBlendCollision::operator==(const ZSoundBlendCollision& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSoundBlendCollision>)
		return false;


	return true;
}

ZHMTypeInfo ZSpeakerLevels::TypeInfo = ZHMTypeInfo("ZSpeakerLevels", sizeof(ZSpeakerLevels), alignof(ZSpeakerLevels), ZSpeakerLevels::WriteJson, ZSpeakerLevels::WriteSimpleJson, ZSpeakerLevels::FromSimpleJson, ZSpeakerLevels::Serialize, ZSpeakerLevels::Equals);

void ZSpeakerLevels::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aSpeakerMatrix") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<float32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpeakerMatrix.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpeakerMatrix[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aSpeakerMatrix.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZSpeakerLevels::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSpeakerMatrix") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpeakerMatrix.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpeakerMatrix[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSpeakerMatrix.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZSpeakerLevels::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSpeakerLevels s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSpeakerMatrix"];
	s_Object.m_aSpeakerMatrix.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aSpeakerMatrix[s_Index0++] = simdjson::from_json_float32(s_Item0);
	}
	}

	*reinterpret_cast<ZSpeakerLevels*>(p_Target) = s_Object;
}

void ZSpeakerLevels::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Object);

	TArray<float32>::Serialize(&s_Object->m_aSpeakerMatrix, p_Serializer, p_OwnOffset + offsetof(ZSpeakerLevels, m_aSpeakerMatrix));
}

bool ZSpeakerLevels::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSpeakerLevels*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSpeakerLevels*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSpeakerLevels::operator==(const ZSpeakerLevels& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSpeakerLevels>)
		return false;

	if (m_aSpeakerMatrix != p_Other.m_aSpeakerMatrix) return false;

	return true;
}

ZHMTypeInfo ZTime::TypeInfo = ZHMTypeInfo("ZTime", sizeof(ZTime), alignof(ZTime), ZTime::WriteJson, ZTime::WriteSimpleJson, ZTime::FromSimpleJson, ZTime::Serialize, ZTime::Equals);

void ZTime::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nValue);
	p_Stream << "}";

	p_Stream << "}";
}

void ZTime::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nValue);

	p_Stream << "}";
}

void ZTime::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZTime s_Object {};

	s_Object.m_nValue = simdjson::from_json_uint64(p_Document["m_nValue"]);

	*reinterpret_cast<ZTime*>(p_Target) = s_Object;
}

void ZTime::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

}

bool ZTime::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTime*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTime*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTime::operator==(const ZTime& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTime>)
		return false;

	if (m_nValue != p_Other.m_nValue) return false;

	return true;
}

