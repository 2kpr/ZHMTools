From 4c730a586bc9eb680f2fc9a67aae53c7e6ed7c3a Mon Sep 17 00:00:00 2001
From: OrfeasZ <orfeaz@gmail.com>
Date: Fri, 8 Oct 2021 19:38:55 +0300
Subject: [PATCH 1/2] [ResourceLib] Re-enable error reporting

---
 Libraries/ResourceLib/Src/External/simdjson.h | 60 ++++++++++++++++++-
 1 file changed, 58 insertions(+), 2 deletions(-)

diff --git a/Libraries/ResourceLib/Src/External/simdjson.h b/Libraries/ResourceLib/Src/External/simdjson.h
index df1f97b..4161316 100644
--- a/Libraries/ResourceLib/Src/External/simdjson.h
+++ b/Libraries/ResourceLib/Src/External/simdjson.h
@@ -2218,6 +2218,8 @@ enum {
 
 namespace simdjson {
 
+static std::string_view g_last_key = "";
+
 /**
  * All possible errors returned by simdjson.
  */
@@ -2280,14 +2282,28 @@ struct simdjson_error : public std::exception {
    * Create an exception from a simdjson error code.
    * @param error The error code
    */
-  simdjson_error(error_code error) noexcept : _error{error} { }
+  simdjson_error(error_code error) noexcept : _error{error}, _last_key(simdjson::g_last_key)
+  {
+      if (last_key().size() > 0) {
+          snprintf(_error_str, sizeof(_error_str), "%s Last field accessed: %s", error_message(_error), std::string(last_key()).c_str());
+      }
+      else {
+          snprintf(_error_str, sizeof(_error_str), "%s", error_message(_error));
+      }
+  }
   /** The error message */
-  const char *what() const noexcept { return error_message(error()); }
+  const char* what() const noexcept { return _error_str; }
   /** The error code */
   error_code error() const noexcept { return _error; }
+  /** The last key accessed before this error */
+  std::string_view last_key() const noexcept { return _last_key; }
 private:
   /** The error code that was used */
   error_code _error;
+  /** The last key accessed before this error */
+  std::string_view _last_key;
+  /** Buffer for the error message. */
+  char _error_str[1024 * 16];
 };
 
 namespace internal {
@@ -5171,6 +5187,29 @@ enum class element_type {
   NULL_VALUE = 'n' ///< null
 };
 
+inline std::string element_type_to_string(element_type type) {
+    switch (type) {
+    case element_type::ARRAY:
+        return "array";
+    case element_type::OBJECT:
+        return "object";
+    case element_type::INT64:
+        return "int64";
+    case element_type::UINT64:
+        return "uint64";
+    case element_type::DOUBLE:
+        return "double";
+    case element_type::STRING:
+        return "string";
+    case element_type::BOOL:
+        return "bool";
+    case element_type::NULL_VALUE:
+        return "null";
+    default:
+        return "";
+    }
+}
+
 /**
  * A JSON element.
  *
@@ -7017,6 +7056,7 @@ inline simdjson_result<bool> element::get_bool() const noexcept {
   } else if(tape.is_false()) {
     return false;
   }
+  fprintf(stderr, "[ERROR] Expected 'bool' type but found '%s'.\n", element_type_to_string(type()).c_str());
   return INCORRECT_TYPE;
 }
 inline simdjson_result<const char *> element::get_c_str() const noexcept {
@@ -7025,6 +7065,7 @@ inline simdjson_result<const char *> element::get_c_str() const noexcept {
       return tape.get_c_str();
     }
     default:
+      fprintf(stderr, "[ERROR] Expected 'string' type but found '%s'.\n", element_type_to_string(type()).c_str());
       return INCORRECT_TYPE;
   }
 }
@@ -7034,6 +7075,7 @@ inline simdjson_result<size_t> element::get_string_length() const noexcept {
       return tape.get_string_length();
     }
     default:
+      fprintf(stderr, "[ERROR] Expected 'string' type but found '%s'.\n", element_type_to_string(type()).c_str());
       return INCORRECT_TYPE;
   }
 }
@@ -7042,6 +7084,7 @@ inline simdjson_result<std::string_view> element::get_string() const noexcept {
     case internal::tape_type::STRING:
       return tape.get_string_view();
     default:
+      fprintf(stderr, "[ERROR] Expected 'string' type but found '%s'.\n", element_type_to_string(type()).c_str());
       return INCORRECT_TYPE;
   }
 }
@@ -7054,6 +7097,7 @@ inline simdjson_result<uint64_t> element::get_uint64() const noexcept {
       }
       return uint64_t(result);
     }
+    fprintf(stderr, "[ERROR] Expected 'uint64' type but found '%s'.\n", element_type_to_string(type()).c_str());
     return INCORRECT_TYPE;
   }
   return tape.next_tape_value<int64_t>();
@@ -7068,6 +7112,7 @@ inline simdjson_result<int64_t> element::get_int64() const noexcept {
       }
       return static_cast<int64_t>(result);
     }
+    fprintf(stderr, "[ERROR] Expected 'int64' type but found '%s'.\n", element_type_to_string(type()).c_str());
     return INCORRECT_TYPE;
   }
   return tape.next_tape_value<int64_t>();
@@ -7088,6 +7133,7 @@ inline simdjson_result<double> element::get_double() const noexcept {
     } else if(tape.is_int64()) {
       return double(tape.next_tape_value<int64_t>());
     }
+    fprintf(stderr, "[ERROR] Expected 'double' type but found '%s'.\n", element_type_to_string(type()).c_str());
     return INCORRECT_TYPE;
   }
   // this is common:
@@ -7098,6 +7144,7 @@ inline simdjson_result<array> element::get_array() const noexcept {
     case internal::tape_type::START_ARRAY:
       return array(tape);
     default:
+      fprintf(stderr, "[ERROR] Expected 'array' type but found '%s'.\n", element_type_to_string(type()).c_str());
       return INCORRECT_TYPE;
   }
 }
@@ -7106,6 +7153,7 @@ inline simdjson_result<object> element::get_object() const noexcept {
     case internal::tape_type::START_OBJECT:
       return object(tape);
     default:
+      fprintf(stderr, "[ERROR] Expected 'object' type but found '%s'.\n", element_type_to_string(type()).c_str());
       return INCORRECT_TYPE;
   }
 }
@@ -7209,9 +7257,11 @@ inline simdjson_result<element> element::at(size_t index) const noexcept {
   return get<array>().at(index);
 }
 inline simdjson_result<element> element::at_key(std::string_view key) const noexcept {
+  g_last_key = key;
   return get<object>().at_key(key);
 }
 inline simdjson_result<element> element::at_key_case_insensitive(std::string_view key) const noexcept {
+  g_last_key = key;
   return get<object>().at_key_case_insensitive(key);
 }
 
@@ -7883,6 +7933,7 @@ inline simdjson_result<element> object::at_pointer(std::string_view json_pointer
 }
 
 inline simdjson_result<element> object::at_key(std::string_view key) const noexcept {
+  g_last_key = key;
   iterator end_field = end();
   for (iterator field = begin(); field != end_field; ++field) {
     if (field.key_equals(key)) {
@@ -7895,6 +7946,7 @@ inline simdjson_result<element> object::at_key(std::string_view key) const noexc
 // https://github.com/simdjson/simdjson/issues/323
 // People do seek keys in a case-insensitive manner.
 inline simdjson_result<element> object::at_key_case_insensitive(std::string_view key) const noexcept {
+  g_last_key = key;
   iterator end_field = end();
   for (iterator field = begin(); field != end_field; ++field) {
     if (field.key_equals_case_insensitive(key)) {
@@ -28454,12 +28506,14 @@ namespace SIMDJSON_BUILTIN_IMPLEMENTATION {
 namespace ondemand {
 
 simdjson_really_inline simdjson_result<value> object::find_field_unordered(const std::string_view key) & noexcept {
+  g_last_key = key;
   bool has_value;
   SIMDJSON_TRY( iter.find_field_unordered_raw(key).get(has_value) );
   if (!has_value) { return NO_SUCH_FIELD; }
   return value(iter.child());
 }
 simdjson_really_inline simdjson_result<value> object::find_field_unordered(const std::string_view key) && noexcept {
+  g_last_key = key;
   bool has_value;
   SIMDJSON_TRY( iter.find_field_unordered_raw(key).get(has_value) );
   if (!has_value) { return NO_SUCH_FIELD; }
@@ -28472,12 +28526,14 @@ simdjson_really_inline simdjson_result<value> object::operator[](const std::stri
   return std::forward<object>(*this).find_field_unordered(key);
 }
 simdjson_really_inline simdjson_result<value> object::find_field(const std::string_view key) & noexcept {
+  g_last_key = key;
   bool has_value;
   SIMDJSON_TRY( iter.find_field_raw(key).get(has_value) );
   if (!has_value) { return NO_SUCH_FIELD; }
   return value(iter.child());
 }
 simdjson_really_inline simdjson_result<value> object::find_field(const std::string_view key) && noexcept {
+  g_last_key = key;
   bool has_value;
   SIMDJSON_TRY( iter.find_field_raw(key).get(has_value) );
   if (!has_value) { return NO_SUCH_FIELD; }
-- 
2.31.1.windows.1

